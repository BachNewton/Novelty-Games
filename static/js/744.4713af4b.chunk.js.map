{"version":3,"file":"static/js/744.4713af4b.chunk.js","mappings":"mBAMA,MAAMA,EAAa,GAAG,IAEjBC,EAAS,SAATA,GAAS,OAATA,EAAAA,EAAS,2BAATA,EAAAA,EAAS,iBAATA,EAAAA,EAAS,iCAATA,EAAAA,EAAS,iBAATA,EAAAA,EAAS,mBAATA,EAAAA,EAAS,mBAATA,EAAAA,EAAS,mBAATA,EAAAA,EAAS,mBAATA,EAAAA,EAAS,iBAATA,EAAAA,EAAS,yBAATA,EAAAA,EAAS,4BAATA,EAAAA,EAAS,oBAATA,EAAAA,EAAS,kBAATA,EAAAA,EAAS,gBAATA,EAAAA,EAAS,kBAATA,CAAS,EAATA,GAAS,IAkBTC,EAAQ,SAARA,GAAQ,OAARA,EAAAA,EAAQ,eAARA,EAAAA,EAAQ,eAARA,EAAAA,EAAQ,iBAARA,EAAAA,EAAQ,eAARA,CAAQ,EAARA,GAAQ,IAORC,EAAS,SAATA,GAAS,OAATA,EAAAA,EAAS,eAATA,EAAAA,EAAS,eAATA,EAAAA,EAAS,qBAATA,EAAAA,EAAS,mBAATA,EAAAA,EAAS,uBAATA,EAAAA,EAAS,mCAATA,EAAAA,EAAS,eAATA,EAAAA,EAAS,iBAATA,EAAAA,EAAS,aAATA,EAAAA,EAAS,iBAATA,EAAAA,EAAS,oBAATA,EAAAA,EAAS,oBAATA,CAAS,EAATA,GAAS,IAeTC,EAAW,SAAXA,GAAW,OAAXA,EAAAA,EAAW,mBAAXA,EAAAA,EAAW,mBAAXA,EAAAA,EAAW,iBAAXA,EAAAA,EAAW,mBAAXA,EAAAA,EAAW,qBAAXA,EAAAA,EAAW,qBAAXA,CAAW,EAAXA,GAAW,IA0FhB,SAASC,EAAmBC,GACxB,IAAIC,EAAQD,IAAS,EAErB,SAASE,IACLD,GAAS,EACTA,EAASA,EAAQ,WAAc,EAC/B,IAAIE,EAAIC,KAAKC,KAAKJ,EAASA,IAAU,GAAK,EAAIA,GAE9C,OADAE,EAAKA,EAAIC,KAAKC,KAAKF,EAAKA,IAAM,EAAI,GAAKA,GAAMA,IACpCA,EAAKA,IAAM,MAAS,GAAK,UACtC,CAEA,MAAO,CACHD,OACAI,QAAUC,GAAQH,KAAKI,MAAMN,IAASK,GACtCE,UAAWA,CAACC,EAAKH,IAAQG,EAAMR,KAAUK,EAAMG,GAC/CC,SAAU,eAACC,EAAWC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,GAAG,OAAKX,IAASU,CAAW,EACrDI,QAAaC,IACT,MAAMC,EAAS,IAAID,GACnB,IAAK,IAAIE,EAAID,EAAOJ,OAAS,EAAGK,EAAI,EAAGA,IAAK,CACxC,MAAMC,EAAIhB,KAAKI,MAAMN,KAAUiB,EAAI,KAClCD,EAAOC,GAAID,EAAOE,IAAM,CAACF,EAAOE,GAAIF,EAAOC,GAChD,CACA,OAAOD,CAAM,EAEjBG,KAAUJ,GAAkBA,EAAMb,KAAKI,MAAMN,IAASe,EAAMH,SAEpE,CAEA,SAASQ,EAAeC,EAAWC,EAAWxB,GAC1C,IAAIyB,EAAOzB,EAIX,OAHAyB,EAAOrB,KAAKC,KAAKoB,EAAQF,EAAQ,YACjCE,EAAOrB,KAAKC,KAAKoB,EAAQD,EAAQ,YACjCC,GAAQA,IAAS,GACVA,IAAS,CACpB,CAGA,MAAMC,EAA4B,CAC9B,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,GAAI,EAAE,GAAI,GAChC,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,IAG5BC,EAAK,IAAOvB,KAAKwB,KAAK,GAAK,GAC3BC,GAAM,EAAIzB,KAAKwB,KAAK,IAAM,EAQhC,SAASE,EAAqB9B,GAC1B,MAAM+B,EAAMhC,EAAmBC,GACzBgC,EAAiB,GACjBC,EAAqB,GAE3B,IAAK,IAAId,EAAI,EAAGA,EAAI,IAAKA,IACrBa,EAAKb,GAAKA,EAGd,IAAK,IAAIA,EAAI,IAAKA,EAAI,EAAGA,IAAK,CAC1B,MAAMC,EAAIW,EAAIzB,QAAQa,EAAI,IACzBa,EAAKb,GAAIa,EAAKZ,IAAM,CAACY,EAAKZ,GAAIY,EAAKb,GACxC,CAEA,IAAK,IAAIA,EAAI,EAAGA,EAAI,IAAKA,IACrBa,EAAKb,GAAKa,EAAS,IAAJb,GACfc,EAASd,GAAe,EAAVa,EAAKb,GAGvB,SAASe,EAAKC,EAAYC,EAAYb,EAAWC,GAC7C,OAAOW,EAAKZ,EAAIa,EAAKZ,CACzB,CAEA,SAASa,EAAQd,EAAWC,GACxB,MAAMc,GAAKf,EAAIC,GAAKG,EACdR,EAAIf,KAAKI,MAAMe,EAAIe,GACnBlB,EAAIhB,KAAKI,MAAMgB,EAAIc,GAEnBnC,GAAKgB,EAAIC,GAAKS,EAGdU,EAAKhB,GAFAJ,EAAIhB,GAGTqC,EAAKhB,GAFAJ,EAAIjB,GAIf,IAAIsC,EAAYC,EACZH,EAAKC,GACLC,EAAK,EACLC,EAAK,IAELD,EAAK,EACLC,EAAK,GAGT,MAAMC,EAAKJ,EAAKE,EAAKZ,EACfe,EAAKJ,EAAKE,EAAKb,EACfgB,EAAKN,EAAK,EAAI,EAAIV,EAClBiB,EAAKN,EAAK,EAAI,EAAIX,EAElBkB,EAAS,IAAJ5B,EACL6B,EAAS,IAAJ5B,EAEX,IAAI6B,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAErBC,EAAK,GAAMb,EAAKA,EAAKC,EAAKA,EAC9B,GAAIY,GAAM,EAAG,CACTA,GAAMA,EACN,MAAMC,EAAMpB,EAASc,EAAKf,EAAKgB,KACxBM,EAAKC,GAAO7B,EAAM2B,GACzBJ,EAAKG,EAAKA,EAAKlB,EAAKoB,EAAKC,EAAKhB,EAAIC,EACtC,CAEA,IAAIgB,EAAK,GAAMb,EAAKA,EAAKC,EAAKA,EAC9B,GAAIY,GAAM,EAAG,CACTA,GAAMA,EACN,MAAMC,EAAMxB,EAASc,EAAKN,EAAKT,EAAKgB,EAAKN,KAClCgB,EAAKC,GAAOjC,EAAM+B,GACzBP,EAAKM,EAAKA,EAAKtB,EAAKwB,EAAKC,EAAKhB,EAAIC,EACtC,CAEA,IAAIgB,EAAK,GAAMf,EAAKA,EAAKC,EAAKA,EAC9B,GAAIc,GAAM,EAAG,CACTA,GAAMA,EACN,MAAMC,EAAM5B,EAASc,EAAK,EAAIf,EAAKgB,EAAK,KACjCc,EAAKC,GAAOrC,EAAMmC,GACzBV,EAAKS,EAAKA,EAAK1B,EAAK4B,EAAKC,EAAKlB,EAAIC,EACtC,CAEA,OAAO,IAAMG,EAAKC,EAAKC,EAC3B,CAmCA,MAAO,CAAEd,UAAS2B,cAjClB,SAAuBzC,EAAWC,EAAWyC,EAAiBC,EAAqBC,GAC/E,IAAIC,EAAQ,EACRC,EAAY,EACZC,EAAY,EACZC,EAAW,EAEf,IAAK,IAAIpD,EAAI,EAAGA,EAAI8C,EAAS9C,IACzBiD,GAAS/B,EAAQd,EAAI+C,EAAW9C,EAAI8C,GAAaD,EACjDE,GAAYF,EACZA,GAAaH,EACbI,GAAaH,EAGjB,OAAOC,EAAQG,CACnB,EAmBiCC,cAjBjC,SAAuBjD,EAAWC,EAAWyC,EAAiBC,EAAqBC,GAC/E,IAAIC,EAAQ,EACRC,EAAY,EACZC,EAAY,EACZC,EAAW,EAEf,IAAK,IAAIpD,EAAI,EAAGA,EAAI8C,EAAS9C,IAAK,CAC9B,MAAMsD,EAAI,EAAIrE,KAAKsE,IAAIrC,EAAQd,EAAI+C,EAAW9C,EAAI8C,IAClDF,GAASK,EAAIA,EAAIJ,EACjBE,GAAYF,EACZA,GAAaH,EACbI,GAAaH,CACjB,CAEA,OAAOC,EAAQG,CACnB,EAGJ,CAGA,MAAMI,EAAkB,KAClBC,EAAiB,KACjBC,EAAe,IACfC,EAAiB,IACjBC,EAAa,KAQnB,SAASC,EAAuBhF,GAC5B,MAAMiF,EAAiBnD,EAAqB9B,GACtCkF,EAAgBpD,EAAqB9B,EAAO,KAC5CmF,EAAcrD,EAAqB9B,EAAO,KAC1CoF,EAAgBtD,EAAqB9B,EAAO,KAC5CqF,EAAmBvD,EAAqB9B,EAAO,KAOrD,MAAO,CACHsF,aAAcA,CAACC,EAAQC,KACnB,MAAMC,EAAYR,EAAejB,cAC7BuB,EAASZ,EAAiBa,EAASb,EAAiB,EAAG,GAAK,GAE1De,EAAYR,EAAcV,cAC5Be,EAASX,EAAgBY,EAASZ,EAAgB,EAAG,GAAK,GAExDe,EAEF,IAFWR,EAAYnB,cACvBuB,EAASV,EAAcW,EAASX,EAAc,EAAG,GAAK,GAO1D,MAHkC,GAAZY,EACmB,GAAZC,EAnBrC,SAAoBE,EAAeC,EAAetE,GAC9C,MAAMpB,EAAIC,KAAKG,IAAI,EAAGH,KAAKM,IAAI,GAAIa,EAAIqE,IAAUC,EAAQD,KACzD,OAAOzF,EAAIA,GAAK,EAAI,EAAIA,EAC5B,CAcyB2F,EAAY,GAAK,GAAKL,GAIOE,CAAM,EAGxDI,YAAaA,CAACR,EAAQC,IAIH,GAHDJ,EAAcpB,cACxBuB,EAAST,EAAgBU,EAASV,EAAgB,EAAG,GAAK,GAEzC,GAGzBkB,eAAgBA,CAACT,EAAQC,KACrB,MAAMS,EAA4C,GAA3B7F,KAAK8F,IAAa,KAATV,GAAwB,GAClDW,EAEF,GAFgBd,EAAiBrB,cACjCuB,EAASR,EAAYS,EAAST,EAAY,EAAG,GAAK,GAEtD,OAAO3E,KAAKG,IAAI,EAAGH,KAAKM,IAAI,EAAGuF,EAAiBE,GAAa,EAGzE,CAGA,SAASC,EAAcC,EAAmBC,EAAkBC,GACxD,OAAIF,GAAa,GAAY1G,EAAU6G,WACnCH,GAAa,IAAa1G,EAAU8G,MACpCJ,GAAa,IAAa1G,EAAU+G,cACpCL,EAAY,IAAa1G,EAAUgH,MAEnCN,EAAY,IAAa1G,EAAUiH,WACnCP,EAAY,GAAY1G,EAAUkH,UAClCR,EAAY,IAAa1G,EAAUmH,MAEnCP,EAAc,IAAa5G,EAAUoH,OAErCT,EAAW,IAAa3G,EAAUqH,OAElCV,EAAW,GACPC,EAAc,GAAY5G,EAAUqH,OACjCrH,EAAUsH,OAGjBX,EAAW,GACPC,EAAc,IAAa5G,EAAUuH,OACrCX,EAAc,IAAa5G,EAAUwH,MAClCxH,EAAUyH,OAGjBd,EAAW,GACPC,EAAc,GAAY5G,EAAUuH,OACjCvH,EAAUyH,OAGdzH,EAAUsH,MACrB,CAgBA,MAAMI,EAA6C,CAC/C,CAACvH,EAAYwH,QAAS,CAClBC,SAAU,CAAC,OAAQ,QAAS,OAAQ,QAAS,OAAQ,QAAS,OAAQ,MAAO,QAAS,QACtFC,MAAO,CAAC,OAAQ,OAAQ,QAAS,MAAO,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,QAC/EC,SAAU,CAAC,KAAM,GAAI,OAAQ,KAAM,SAEvC,CAAC3H,EAAY4H,QAAS,CAClBH,SAAU,CAAC,MAAO,OAAQ,QAAS,MAAO,SAAU,OAAQ,MAAO,OAAQ,MAAO,SAClFC,MAAO,CAAC,OAAQ,QAAS,SAAU,OAAQ,OAAQ,MAAO,OAAQ,QAAS,OAAQ,QACnFC,SAAU,CAAC,GAAI,KAAM,KAAM,MAAO,OAEtC,CAAC3H,EAAY6H,OAAQ,CACjBJ,SAAU,CAAC,OAAQ,QAAS,QAAS,QAAS,OAAQ,OAAQ,QAAS,MAAO,MAAO,SACrFC,MAAO,CAAC,QAAS,OAAQ,OAAQ,QAAS,OAAQ,MAAO,MAAO,QAAS,OAAQ,UACjFC,SAAU,CAAC,GAAI,KAAM,KAAM,MAAO,QAEtC,CAAC3H,EAAYkH,QAAS,CAClBO,SAAU,CAAC,KAAM,KAAM,MAAO,MAAO,MAAO,OAAQ,MAAO,MAAO,QAAS,OAC3EC,MAAO,CAAC,SAAU,QAAS,QAAS,QAAS,QAAS,SAAU,QAAS,QAAS,QAAS,SAC3FC,SAAU,CAAC,GAAI,IAAK,IAAK,OAAQ,SAErC,CAAC3H,EAAY8H,SAAU,CACnBL,SAAU,CAAC,OAAQ,SAAU,SAAU,SAAU,UAAW,OAAQ,MAAO,QAAS,QAAS,SAC7FC,MAAO,CAAC,OAAQ,QAAS,OAAQ,SAAU,SAAU,SAAU,SAAU,OAAQ,SAAU,YAC3FC,SAAU,CAAC,GAAI,UAAW,WAAY,YAAa,KAEvD,CAAC3H,EAAY+H,SAAU,CACnBN,SAAU,CAAC,SAAU,UAAW,SAAU,QAAS,QAAS,OAAQ,OAAQ,OAAQ,OAAQ,QAC5FC,MAAO,CAAC,OAAQ,OAAQ,QAAS,QAAS,OAAQ,OAAQ,OAAQ,QAAS,OAAQ,SACnFC,SAAU,CAAC,GAAI,QAAS,OAAQ,OAAQ,UAI1CK,EAA2C,CAC7C,CAACnI,EAAU6G,YAAa,CAAC,QAAS,SAAU,QAC5C,CAAC7G,EAAU8G,OAAQ,CAAC,MAAO,SAAU,SACrC,CAAC9G,EAAU+G,eAAgB,CAAC,MAAO,OAAQ,UAC3C,CAAC/G,EAAUgH,OAAQ,CAAC,QAAS,QAAS,UACtC,CAAChH,EAAUsH,QAAS,CAAC,SAAU,aAAc,UAAW,WACxD,CAACtH,EAAUyH,QAAS,CAAC,SAAU,QAAS,WAAY,SACpD,CAACzH,EAAUuH,QAAS,CAAC,SAAU,aAAc,SAC7C,CAACvH,EAAUqH,QAAS,CAAC,SAAU,SAAU,QAAS,SAClD,CAACrH,EAAUmH,OAAQ,CAAC,QAAS,YAAa,SAC1C,CAACnH,EAAUkH,WAAY,CAAC,YAAa,QAAS,QAAS,WACvD,CAAClH,EAAUiH,YAAa,CAAC,aAAc,WAAY,YACnD,CAACjH,EAAUoH,QAAS,CAAC,SAAU,SAAU,UAAW,WACpD,CAACpH,EAAUwH,OAAQ,CAAC,QAAS,QAAS,MAAO,QAC7C,CAACxH,EAAUoI,MAAO,CAAC,OAAQ,OAAQ,QACnC,CAACpI,EAAUqI,OAAQ,CAAC,QAAS,SAAU,WA4C3C,SAASC,EAAqB1C,EAAgBC,EAAgBxF,GAC1D,MAAMkI,EAAc5G,EAAelB,KAAKI,MAAM+E,EAAS,KAAMnF,KAAKI,MAAMgF,EAAS,KAAMxF,EAAO,KACxFmI,EAAS,CACXrI,EAAYwH,OAAQxH,EAAY4H,OAAQ5H,EAAY6H,MACpD7H,EAAYkH,OAAQlH,EAAY8H,QAAS9H,EAAY+H,SAEzD,OAAOM,EAAOD,EAAcC,EAAOrH,OACvC,CAuEA,SAASsH,EACLzF,EAAYC,EAAYC,EAAYC,EACpCuF,EAAYC,EAAYC,GAExB,MAAMC,EAAK3F,EAAKF,EACV8F,EAAK3F,EAAKF,EAEhB,GADYxC,KAAKwB,KAAK4G,EAAKA,EAAKC,EAAKA,GAC3B,GAAK,OAAO,KAEtB,MAAMC,EAAK/F,EAAK0F,EACVM,EAAK/F,EAAK0F,EACVM,EAAIJ,EAAKA,EAAKC,EAAKA,EACnBI,EAAI,GAAKH,EAAKF,EAAKG,EAAKF,GAExBK,EAAeD,EAAIA,EAAI,EAAID,GADvBF,EAAKA,EAAKC,EAAKA,EAAKJ,EAAIA,GAGlC,GAAIO,EAAe,EAAG,OAAO,KAE7B,MAAMC,EAAQ3I,KAAKwB,KAAKkH,GAClBtF,IAAOqF,EAAIE,IAAU,EAAIH,GACzBhF,IAAOiF,EAAIE,IAAU,EAAIH,GAE/B,GAAIhF,EAAK,GAAKJ,EAAK,EAAG,OAAO,KAE7B,MAAMwF,EAAY5I,KAAKG,IAAI,EAAGiD,GACxByF,EAAY7I,KAAKM,IAAI,EAAGkD,GAE9B,MAAO,CACH,CAAE2B,OAAQ5C,EAAK6F,EAAKQ,EAAWxD,OAAQ5C,EAAK6F,EAAKO,GACjD,CAAEzD,OAAQ5C,EAAK6F,EAAKS,EAAWzD,OAAQ5C,EAAK6F,EAAKQ,GAEzD,CAgEA,SAASC,EAAoBC,EAAYC,EAAYzG,EAAYC,EAAYC,EAAYC,GACrF,MAAM0F,EAAK3F,EAAKF,EACV8F,EAAK3F,EAAKF,EACVyG,EAAOb,EAAKA,EAAKC,EAAKA,EAE5B,GAAIY,EAAO,KACP,OAAOjJ,KAAKwB,MAAMuH,EAAKxG,IAAO,GAAKyG,EAAKxG,IAAO,GAGnD,MAAMzC,EAAIC,KAAKG,IAAI,EAAGH,KAAKM,IAAI,IAAKyI,EAAKxG,GAAM6F,GAAMY,EAAKxG,GAAM6F,GAAMY,IAChEC,EAAQ3G,EAAKxC,EAAIqI,EACjBe,EAAQ3G,EAAKzC,EAAIsI,EAEvB,OAAOrI,KAAKwB,MAAMuH,EAAKG,IAAU,GAAKF,EAAKG,IAAU,EACzD,CAoDA,SAASC,EACLC,EAAiBC,EAAwB1J,EACzC+B,EAAmB4H,EAA2BC,GAE9C,MAAMC,EAAiB,GAEvB,GAAI9H,EAAI7B,OAAS,IAAM,OAAO2J,EAE9B,IAAIC,EAAY,EACZC,EAAQrK,EAAa,EACrBsK,EAAQtK,EAAa,EAEzB,IAAK,IAAI8B,EAAI,EAAGA,EAAI9B,EAAa,EAAG8B,GAAK,EACrC,IAAK,IAAID,EAAI,EAAGA,EAAI7B,EAAa,EAAG6B,GAAK,EAAG,CACxC,MAAM0I,EAAOR,EAAMjI,GAAGD,GACtB,IAxWY2I,EAwWQD,EAAKC,SAvWhBvK,EAAUsH,QACpBiD,IAAUvK,EAAUyH,QACpB8C,IAAUvK,EAAUmH,OACpBoD,IAAUvK,EAAUgH,MAoWc,SAEjC,IAAIwD,EAAQ,EACZA,GAAgD,GAAtC,EAAI/J,KAAKsE,IAAIuF,EAAK5D,UAAY,KACxC8D,GAA+C,KAArC,EAAI/J,KAAKsE,IAAIuF,EAAK3D,SAAW,KAEvC,IAAK,IAAImC,GAAM,EAAGA,GAAM,EAAGA,IACvB,IAAK,IAAID,GAAM,EAAGA,GAAM,EAAGA,IAAM,CAC7B,MAAM4B,EAAK5I,EAAIiH,EACT4B,EAAK9I,EAAIiH,EACf,GAAI4B,GAAM,GAAKA,EAAK1K,GAAc2K,GAAM,GAAKA,EAAK3K,EAAY,CAC1D,MAAM4K,EAAWb,EAAMW,GAAIC,GACvBC,EAASJ,QAAUvK,EAAUqI,OAASsC,EAASJ,QAAUvK,EAAU+G,gBACnEyD,GAAS,GAEjB,CACJ,CAGAA,EAAQL,IACRA,EAAYK,EACZJ,EAAQxI,EACRyI,EAAQxI,EAEhB,CAhYR,IAAwB0I,EAmYpB,GAAIJ,EAAY,EAAG,OAAOD,EAE1B,MAAMtE,EAASmE,EAAMa,OAAS7K,EAAaqK,EACrCvE,EAASkE,EAAMc,OAAS9K,EAAasK,EACrCS,EAAcxC,EAAqB1C,EAAQC,EAAQxF,GACnD0K,EAAOd,EAAQe,iBAAiBF,EAAalF,EAAQC,GACrDoF,EAAaxK,KAAKI,MAAM,IAAmB,IAAbuB,EAAI7B,QAClC2K,EAAS,EAAIzK,KAAKwB,KAAKgJ,EAAa,KAEpCE,EAAU/K,EAAmBuB,EAAeiE,EAAQC,EAAQxF,EAAO,MACnE+K,EApLV,SAA6BC,EAAiBC,EAAiBJ,EAAgB9I,GAC3E,MAAMgJ,EAAoB,GAG1B,GAFiBhJ,EAAI7B,OAAS,GAEhB,CACV,MAAMgL,EAAa,EAAI9K,KAAKI,MAAmB,EAAbuB,EAAI7B,QACtC,IAAK,IAAIiB,EAAI,EAAGA,EAAI+J,EAAY/J,IAAK,CACjC,MAAMgK,EAAShK,EAAI+J,EAAc9K,KAAKgL,GAAK,EAAiB,GAAbrJ,EAAI7B,OACnD6K,EAAQM,KAAK,CACTC,KAAM,OACNC,OAAQ,CACJ,CAAEhG,OAAQyF,EAASxF,OAAQyF,GAC3B,CAAE1F,OAAQyF,EAAU5K,KAAK8F,IAAIiF,GAASN,EAAS,IAAMrF,OAAQyF,EAAU7K,KAAKoL,IAAIL,GAASN,EAAS,OAG9G,CAEA,MAAMY,EAAWrL,KAAKI,MAAMqK,EAAS,GACrC,IAAK,IAAItC,EAAI,EAAGA,GAAKkD,EAAUlD,IAAK,CAChC,MAAMmD,EAAcnD,EAAIkD,EAAYZ,EAAS,GACvCc,EAAW,GACXJ,EAA+C,GACrD,IAAK,IAAIpK,EAAI,EAAGA,GAAKwK,EAAUxK,IAAK,CAChC,MAAMgK,EAAShK,EAAIwK,EAAYvL,KAAKgL,GAAK,EACzCG,EAAOF,KAAK,CAAE9F,OAAQyF,EAAU5K,KAAK8F,IAAIiF,GAASO,EAAYlG,OAAQyF,EAAU7K,KAAKoL,IAAIL,GAASO,GACtG,CACAX,EAAQM,KAAK,CAAEC,KAAM,YAAaC,UACtC,CACJ,KAAO,CACH,MAAMK,EAAc,IAAmB,EAAb7J,EAAI7B,OACxB2L,EAAY9J,EAAI7B,OAASE,KAAKgL,GAAK,EACnCU,EAAO1L,KAAK8F,IAAI2F,GAChBE,EAAO3L,KAAKoL,IAAIK,GAEtB,IAAK,IAAIG,GAAUnB,EAAQmB,GAAUnB,EAAQmB,GAAUJ,EAAa,CAChE,MAKML,EAASnD,EALA4C,EAAUgB,EAASF,EAAOjB,EAASkB,EACnCd,EAAUe,EAASD,EAAOlB,EAASiB,EACrCd,EAAUgB,EAASF,EAAOjB,EAASkB,EACnCd,EAAUe,EAASD,EAAOlB,EAASiB,EAEYd,EAASC,EAAkB,GAATJ,GAC1EU,GACAR,EAAQM,KAAK,CAAEC,KAAMlL,KAAKsE,IAAIsH,GAAUJ,EAAc,OAAS,YAAaL,UAEpF,CAEA,IAAK,IAAIS,GAAUnB,EAAQmB,GAAUnB,EAAQmB,GAAUJ,EAAa,CAChE,MAKML,EAASnD,EALA4C,EAAUgB,EAASD,EAAOlB,EAASiB,EACnCb,EAAUe,EAASF,EAAOjB,EAASkB,EACrCf,EAAUgB,EAASD,EAAOlB,EAASiB,EACnCb,EAAUe,EAASF,EAAOjB,EAASkB,EAEYf,EAASC,EAAkB,GAATJ,GAC1EU,GACAR,EAAQM,KAAK,CAAEC,KAAMlL,KAAKsE,IAAIsH,GAAUJ,EAAc,OAAS,YAAaL,UAEpF,CACJ,CAEA,OAAOR,CACX,CAwHoBkB,CAAoB1G,EAAQC,EAAQqF,EAAQC,GACtDoB,EAvGV,SAA+BlB,EAAiBC,EAAiBJ,EAAgBE,EAAmBhJ,GAChG,MAAMmK,EAAwB,GACxBC,EAAkB,GAAmB,GAAbpK,EAAI7B,OAGlC,IAAK,IAAIuI,GAAMoC,EAAQpC,EAAKoC,EAAQpC,GAFnB,GAGb,IAAK,IAAID,GAAMqC,EAAQrC,EAAKqC,EAAQrC,GAHvB,GAGuC,CAEhD,GADapI,KAAKwB,KAAK4G,EAAKA,EAAKC,EAAKA,GAClB,IAAToC,EAAe,SAE1B,GAAI9I,EAAI7B,OAASiM,EAAiB,SAElC,MAAMC,EAAKpB,EAAUxC,EAA0B,IAApBzG,EAAI7B,OAAS,IAClCmM,EAAKpB,EAAUxC,EAA0B,IAApB1G,EAAI7B,OAAS,IAExC,IAAIoM,GAAmB,EACvB,IAAK,MAAMC,KAAUxB,EAAS,CAC1B,IAAK,IAAI5J,EAAI,EAAGA,EAAIoL,EAAOhB,OAAOzK,OAAS,EAAGK,IAAK,CAC/C,MAAMqL,EAAKD,EAAOhB,OAAOpK,GACnBsL,EAAKF,EAAOhB,OAAOpK,EAAI,GAE7B,GADqB+H,EAAoBkD,EAAIC,EAAIG,EAAGjH,OAAQiH,EAAGhH,OAAQiH,EAAGlH,OAAQkH,EAAGjH,QAClE,GAAK,CACpB8G,GAAmB,EACnB,KACJ,CACJ,CACA,GAAIA,EAAkB,KAC1B,CAEA,GAAIA,EAAkB,SAEtB,MAAMI,EAAQ,IAAoB,GAAb3K,EAAI7B,OACnByM,EAAS,IAAoB,GAAb5K,EAAI7B,OAE1BgM,EAAUb,KAAK,CACXuB,GAAI,YAAYR,EAAGS,QAAQ,MAAMR,EAAGQ,QAAQ,KAC5CC,UAAW,CACP,CAAEvH,OAAQ6G,EAAKM,EAAQ,EAAGlH,OAAQ6G,EAAKM,EAAS,GAChD,CAAEpH,OAAQ6G,EAAKM,EAAQ,EAAGlH,OAAQ6G,EAAKM,EAAS,GAChD,CAAEpH,OAAQ6G,EAAKM,EAAQ,EAAGlH,OAAQ6G,EAAKM,EAAS,GAChD,CAAEpH,OAAQ6G,EAAKM,EAAQ,EAAGlH,OAAQ6G,EAAKM,EAAS,IAEpDA,OAAQ,EAAiB,EAAb5K,EAAI7B,QAExB,CAGJ,OAAOgM,CACX,CAuDsBa,CAAsBxH,EAAQC,EAAQqF,EAAQE,EAASD,GAEnEkC,EAAa,CACfJ,GAAI,QAAQrH,KAAUC,IACtBkF,OACAM,QAASzF,EACT0F,QAASzF,EACTqF,SACAD,aACAH,cACAM,UACAmB,aAGJrC,EAAOwB,KAAK2B,GAEZ,IAAK,IAAIvE,GAAMrI,KAAK6M,KAAKpC,GAASpC,GAAMrI,KAAK6M,KAAKpC,GAASpC,IACvD,IAAK,IAAID,GAAMpI,KAAK6M,KAAKpC,GAASrC,GAAMpI,KAAK6M,KAAKpC,GAASrC,IAAM,CAE7D,GADapI,KAAKwB,KAAK4G,EAAKA,EAAKC,EAAKA,IAC1BoC,EAAQ,CAChB,MAAMqC,EAAKlD,EAAQvB,EACb0E,EAAKpD,EAAQvB,EACf0E,GAAM,GAAKA,EAAKxN,GAAcyN,GAAM,GAAKA,EAAKzN,IAC9C+J,EAAMyD,GAAIC,GAAIC,OAASJ,EAAKJ,GAEpC,CACJ,CAGJ,OAAO/C,CACX,CAEA,SAASwD,EACL5D,EAAiB6D,EAAkBC,EACnC7D,EAAwB8D,EAAe7D,GAEvC,MAAM8D,EAAc/D,EAAMa,OAAS7K,EAC7BgO,EAAchE,EAAMc,OAAS9K,EAEnC,IAAIsM,EAAS,EAGb,IAAK,IAAI7K,EAAI,EAAGA,EAAIzB,EAAYyB,IAAK,CACjC,IAAIwM,EAAa3B,EACb4B,GAAiB,IAErB,IAAK,IAAIC,GANK,GAMmBA,GANnB,GAM2CA,IAAa,CAClE,IAAItM,EAAWC,EACX+D,EAAgBC,EAUpB,GARkB,aAAd+H,GACAhM,EAAI+L,EAAWO,EACfrM,EAAIL,IAEJI,EAAIJ,EACJK,EAAI8L,EAAWO,GAGftM,EAAI,GAAKA,GAAK7B,GAAc8B,EAAI,GAAKA,GAAK9B,EAAY,SAE1D6F,EAASkI,EAAclM,EACvBiE,EAASkI,EAAclM,EAEvB,MAAM6E,EAAYsD,EAAQrE,aAAaC,EAAQC,GAC/C,GAAIa,GAAa,KAAQA,EAAY,IAAM,SAE3C,MAAM8D,EAA+B,IAAtB/J,KAAKsE,IAAImJ,GAAmBzN,KAAKsE,IAAI2B,EAAY,IAC5D8D,EAAQyD,IACRA,EAAgBzD,EAChBwD,EAAaE,EAErB,CAEA,GAAID,GAAiB,IAAK,CAAC,IAADE,EAGtB,IAAIvM,EAAWC,EAFfwK,EAAS2B,EAGS,aAAdJ,GACAhM,EAAInB,KAAKG,IAAI,EAAGH,KAAKM,IAAIhB,EAAa,EAAG4N,EAAWtB,IACpDxK,EAAIL,IAEJI,EAAIJ,EACJK,EAAIpB,KAAKG,IAAI,EAAGH,KAAKM,IAAIhB,EAAa,EAAG4N,EAAWtB,KAGxD,MAAM/B,EAAe,QAAX6D,EAAGrE,EAAMjI,UAAE,IAAAsM,OAAA,EAARA,EAAWvM,GACpB0I,GAAQA,EAAK8D,WAAanO,EAASoO,OACnC/D,EAAK8D,SAAWnO,EAASqO,MAEjC,CACJ,CACJ,CAEA,SAASC,EACLzE,EAAiB0E,EAAgBC,EAAgBC,EAAcC,EAC/D3E,EAA2BD,EAAwBqE,GAEnD,MAAMN,EAAc/D,EAAMa,OAAS7K,EAC7BgO,EAAchE,EAAMc,OAAS9K,EAM7B6O,EAAkB,GAClBC,EAAY,IAAIC,IAEhBC,EAAkB,CACpBnN,EAAG4M,EAAQ3M,EAAG4M,EAAQO,EAAG,EACzBC,EAAGxO,KAAKsE,IAAI2J,EAAOF,GAAU/N,KAAKsE,IAAI4J,EAAOF,GAC7CS,EAAGzO,KAAKsE,IAAI2J,EAAOF,GAAU/N,KAAKsE,IAAI4J,EAAOF,GAC7CU,OAAQ,MAEZP,EAAQlD,KAAKqD,GAGb,IAAIK,EAAa,EAEjB,KAAOR,EAAQzN,OAAS,GAAKiO,EAHP,KAGmC,CACrDA,IAEAR,EAAQS,MAAK,CAACpG,EAAGC,IAAMD,EAAEiG,EAAIhG,EAAEgG,IAC/B,MAAMI,EAAUV,EAAQW,QAExB,GAAID,EAAQ1N,IAAM8M,GAAQY,EAAQzN,IAAM8M,EAAM,CAC1C,IAAIa,EAAoBF,EACxB,KAAOE,GAAM,CAAC,IAADC,EACT,MAAMnF,EAAoB,QAAhBmF,EAAG3F,EAAM0F,EAAK3N,UAAE,IAAA4N,OAAA,EAAbA,EAAgBD,EAAK5N,GAC9B0I,IAASA,EAAK8D,WAAanO,EAASyP,MACnCtB,IAAanO,EAASoO,MAAQ/D,EAAK8D,WAAanO,EAASoO,QAC1D/D,EAAK8D,SAAWA,GAEpBoB,EAAOA,EAAKL,MAChB,CACA,MACJ,CAEAN,EAAUc,IAAI,GAAGL,EAAQ1N,KAAK0N,EAAQzN,KAEtC,MAAM+N,EAAY,CACd,CAAE/G,GAAI,EAAGC,GAAI,GAAK,CAAED,IAAK,EAAGC,GAAI,GAChC,CAAED,GAAI,EAAGC,GAAI,GAAK,CAAED,GAAI,EAAGC,IAAK,IAGpC,IAAK,MAAM,GAAED,EAAE,GAAEC,KAAQ8G,EAAW,CAAC,IAADC,EAChC,MAAMnF,EAAK4E,EAAQ1N,EAAIiH,EACjB4B,EAAK6E,EAAQzN,EAAIiH,EAEvB,GAAI4B,EAAK,GAAKA,GAAM3K,GAAc0K,EAAK,GAAKA,GAAM1K,EAAY,SAC9D,GAAI8O,EAAUiB,IAAI,GAAGpF,KAAMD,KAAO,SAElC,MAAMH,EAAgB,QAAZuF,EAAG/F,EAAMW,UAAG,IAAAoF,OAAA,EAATA,EAAYnF,GACzB,IAAKJ,EAAM,SAEX,MAAM1E,EAASkI,EAAcpD,EACvB7E,EAASkI,EAActD,EACvB/D,EAAYsD,EAAQrE,aAAaC,EAAQC,GAE/C,GAAIyE,EAAKC,QAAUvK,EAAU8G,OAASwD,EAAKC,QAAUvK,EAAU6G,YAC3DyD,EAAKC,QAAUvK,EAAU+G,eAAiBuD,EAAKC,QAAUvK,EAAUoI,MACnE1B,GAAa,KAAQA,EAAY,IACjC,SAGJ,IAAIqJ,EAAO,EACPrJ,EAAY,IAAMqJ,EAAO,EACpBrJ,EAAY,IAAMqJ,EAAO,EACzBzF,EAAKC,QAAUvK,EAAUqI,QAAO0H,EAAO,GAEhD,MAAMf,EAAIM,EAAQN,EAAIe,EAChBd,EAAIxO,KAAKsE,IAAI2J,EAAOhE,GAAMjK,KAAKsE,IAAI4J,EAAOlE,GAC1CyE,EAAIF,EAAIC,EAERe,EAAWpB,EAAQqB,MAAKnL,GAAKA,EAAElD,IAAM8I,GAAM5F,EAAEjD,IAAM4I,IACrDuF,GAAYA,EAASd,GAAKA,IAE1Bc,GACAA,EAAShB,EAAIA,EACbgB,EAASf,EAAIA,EACbe,EAASd,EAAIA,EACbc,EAASb,OAASG,GAElBV,EAAQlD,KAAK,CAAE9J,EAAG8I,EAAI7I,EAAG4I,EAAIuE,IAAGC,IAAGC,IAAGC,OAAQG,IAEtD,CACJ,CACJ,CAiDA,SAASY,EAAqB3F,GAC1B,OAAQA,GACJ,KAAKvK,EAAUyH,OACf,KAAKzH,EAAUuH,OACX,OAAOrH,EAAUuH,OACrB,KAAKzH,EAAUkH,UACf,KAAKlH,EAAUiH,WACX,OAAO/G,EAAUiQ,eACrB,KAAKnQ,EAAUqH,OACX,OAAOnH,EAAUmH,OACrB,QACI,OAAOnH,EAAUkQ,OAE7B,CA+DA,SAASC,EAActG,EAAwB1J,EAAc2J,EAA2BC,GACpF,MACM7H,EAAMhC,EADMuB,EAAeoI,EAAMa,OAAQb,EAAMc,OAAQxK,IAGvDyJ,EAAkB,GACxB,IAAK,IAAIjI,EAAI,EAAGA,EAAI9B,EAAY8B,IAAK,CACjCiI,EAAMjI,GAAK,GACX,IAAK,IAAID,EAAI,EAAGA,EAAI7B,EAAY6B,IAAK,CACjC,MAAMgE,EAASmE,EAAMa,OAAS7K,EAAa6B,EACrCiE,EAASkE,EAAMc,OAAS9K,EAAa8B,EAErC6E,EAAYsD,EAAQrE,aAAaC,EAAQC,GACzCc,EAAWqD,EAAQ5D,YAAYR,EAAQC,GACvCe,EAAcoD,EAAQ3D,eAAeT,EAAQC,GAC7C0E,EAAQ9D,EAAcC,EAAWC,EAAUC,GAEjDkD,EAAMjI,GAAGD,GAAK,CACV8E,YACAC,WACAC,cACA2D,QACA+F,cAAe,EACflC,SAAUnO,EAASyP,KAE3B,CACJ,EA3mBJ,SAAwB5F,EAAiBC,EAAwB1J,EAAc2J,GAI3E,GAFY5J,EADMuB,EAAeoI,EAAMa,OAAQb,EAAMc,OAAQxK,EAAO,MAG5DE,OAAS,IAAM,OAEvB,IAAIgQ,GAAoB,EACpBC,EAAW,EACXC,EAAW,EAEf,IAAK,IAAI5O,EAAI,EAAGA,EAAI9B,EAAY8B,IAC5B,IAAK,IAAID,EAAI,EAAGA,EAAI7B,EAAY6B,IAAK,CACjC,MAAM0I,EAAOR,EAAMjI,GAAGD,GAClB0I,EAAK5D,UAAY,IAAO4D,EAAK5D,UAAY6J,IACzCA,EAAmBjG,EAAK5D,UACxB8J,EAAW5O,EACX6O,EAAW5O,EAEnB,CAGJ,GAAI0O,EAAmB,GAAK,OAE5B,IAAI3O,EAAI4O,EACJ3O,EAAI4O,EACJrB,EAAa,EACjB,MAAMsB,EAA6B,EAAb3Q,EAEtB,KAAOqP,EAAasB,KACZ9O,EAAI,GAAKA,GAAK7B,GAAc8B,EAAI,GAAKA,GAAK9B,IADf,CAG/B,MAAMuK,EAAOR,EAAMjI,GAAGD,GACtB,GAAI0I,EAAKC,QAAUvK,EAAU8G,OAASwD,EAAKC,QAAUvK,EAAU6G,YAAcyD,EAAKC,QAAUvK,EAAU+G,cAClG,MAGJuD,EAAKgG,cAAgB7P,KAAKM,IAAI,EAAGuJ,EAAKgG,cAAgB,GAAmB,IAAblB,GACxD9E,EAAKC,QAAUvK,EAAUqI,OAASiC,EAAKgG,cAAgB,KACvDhG,EAAKC,MAAQvK,EAAUqI,OAG3B,IAAIsI,EAAkBrG,EAAK5D,UACvBkK,EAAQhP,EACRiP,EAAQhP,EAEZ,MAAM+N,EAAY,CACd,CAAChO,EAAI,EAAGC,GAAI,CAACD,EAAI,EAAGC,GAAI,CAACD,EAAGC,EAAI,GAAI,CAACD,EAAGC,EAAI,GAC5C,CAACD,EAAI,EAAGC,EAAI,GAAI,CAACD,EAAI,EAAGC,EAAI,GAAI,CAACD,EAAI,EAAGC,EAAI,GAAI,CAACD,EAAI,EAAGC,EAAI,IAGhE,IAAK,MAAO6I,EAAID,KAAOmF,EACnB,GAAIlF,GAAM,GAAKA,EAAK3K,GAAc0K,GAAM,GAAKA,EAAK1K,EAAY,CAC1D,MAAM+Q,EAAehH,EAAMW,GAAIC,GAC3BoG,EAAapK,UAAYiK,IACzBA,EAAkBG,EAAapK,UAC/BkK,EAAQlG,EACRmG,EAAQpG,EAEhB,CAGJ,GAAImG,IAAUhP,GAAKiP,IAAUhP,EAAG,MAEhCD,EAAIgP,EACJ/O,EAAIgP,EACJzB,GACJ,CACJ,CA0iBI2B,CAAejH,EAAOC,EAAO1J,GAC7B,MAAM6J,EAASL,EAAeC,EAAOC,EAAO1J,EAAM+B,EAAK4H,EAASC,IAvJpE,SAAuBH,EAAiBI,EAAgBH,EAAwB1J,EAAc2J,GAC1F,MAAM8D,EAAc/D,EAAMa,OAAS7K,EAC7BgO,EAAchE,EAAMc,OAAS9K,EAC7BiR,EAAkB,GAElBC,EAAcxQ,KAAKyQ,MAAMpD,EAAckD,GAAmBA,EAC1DG,EAAc1Q,KAAKyQ,MAAMnD,EAAciD,GAAmBA,EAEhE,IAAK,IAAII,GAAY,GAAkBA,GAAaJ,EAAkBjR,EAAYqR,GAAaJ,EAAiB,CAC5G,MAAMK,EAAOJ,EAAcG,EAAYtD,EACnCuD,IAAS,GAAKA,EAAOtR,EAAa,GAClC2N,EAAa5D,EAAOrJ,KAAKI,MAAMwQ,GAAO,WAAYtH,EAAO1J,EAAM2J,GAGnE,MAAMsH,EAAOH,EAAcC,EAAYrD,EACnCuD,IAAS,GAAKA,EAAOvR,EAAa,GAClC2N,EAAa5D,EAAOrJ,KAAKI,MAAMyQ,GAAO,aAAcvH,EAAO1J,EAAM2J,EAEzE,CAEA,IAAK,MAAMqD,KAAQnD,EAAQ,CACvB,MAAMqH,EAAS9Q,KAAKI,MAAMwM,EAAKhC,QAAUyC,GACnC0D,EAAS/Q,KAAKI,MAAMwM,EAAK/B,QAAUyC,GAEnC0D,EAAmBhR,KAAKyQ,MAAO7D,EAAKhC,QAAW2F,GAAmBA,EAAkBlD,EACpF4D,EAAmBjR,KAAKyQ,MAAO7D,EAAK/B,QAAW0F,GAAmBA,EAAkBjD,EAU1F,GARI0D,GAAoB,GAAKA,EAAmB1R,GAC5CwO,EAAazE,EAAOyH,EAAQC,EAAQ/Q,KAAKI,MAAM4Q,GAAmBD,EAAQxH,EAASD,EAAO9J,EAASqO,OAGnGoD,GAAoB,GAAKA,EAAmB3R,GAC5CwO,EAAazE,EAAOyH,EAAQC,EAAQD,EAAQ9Q,KAAKI,MAAM6Q,GAAmB1H,EAASD,EAAO9J,EAASqO,OAGnGjB,EAAKpC,WAAa,KAAO,CACzB,MAAM0G,EAAalR,KAAKsE,IAAI0M,EAAmBF,GAAU9Q,KAAKsE,IAAI2M,EAAmBF,GAC/E,CAAE5P,EAAGnB,KAAKI,MAAM4Q,GAAmB5P,EAAG2P,GACtC,CAAE5P,EAAG2P,EAAQ1P,EAAGpB,KAAKI,MAAM6Q,IAE7BC,EAAW/P,GAAK,GAAK+P,EAAW/P,EAAI7B,GAAc4R,EAAW9P,GAAK,GAAK8P,EAAW9P,EAAI9B,GACtFwO,EAAazE,EAAOyH,EAAQC,EAAQG,EAAW/P,EAAG+P,EAAW9P,EAAGmI,EAASD,EAAO9J,EAASoO,KAEjG,CACJ,CACJ,CA2GIuD,CAAc9H,EAAOI,EAAQH,EAAO1J,EAAM2J,GAC1C,MAAM6H,EA3FV,SAAwB/H,EAAiBI,EAAgBH,EAAwB1J,EAAc4J,GAC3F,MAAM4H,EAAkB,GAExB,IAAK,MAAMxE,KAAQnD,EACf2H,EAAOnG,KAAK,CACRuB,GAAI,SAASI,EAAKJ,KAClB6E,KAAMzE,EAAKtC,KACXnF,OAAQyH,EAAKhC,QACbxF,OAAQwH,EAAK/B,QAAU+B,EAAKnC,OAAS,EACrCS,KAAM0B,EAAKpC,WAAa,IAAQ/K,EAAU6R,KAAO7R,EAAU8R,KAC3DC,QAAS5E,EAAKpC,WAAa,IAAQ,GAAM,EACzCiH,QAAS,IACTC,SAAU9E,EAAKpC,WAAa,IAAQ,GAAK,KAMjD,GAFiB7K,EAAmBuB,EAAeoI,EAAMa,OAAQb,EAAMc,OAAQxK,EAAO,MAEzEE,OAAS,GAAK,CACvB,MAAM6R,EAAc,IAAIC,IACxB,IAAK,IAAIxQ,EAAI,EAAGA,EAAI9B,EAAY8B,IAC5B,IAAK,IAAID,EAAI,EAAGA,EAAI7B,EAAY6B,IAAK,CACjC,MAAM2I,EAAQT,EAAMjI,GAAGD,GAAG2I,MAC1B6H,EAAYE,IAAI/H,GAAQ6H,EAAYG,IAAIhI,IAAU,GAAK,EAC3D,CAGJ,IAAIiI,EAAgBxS,EAAUsH,OAC1BmL,EAAW,EACf,IAAK,MAAOlI,EAAOmI,KAAUN,EACrBM,EAAQD,GAAYlI,IAAUvK,EAAU8G,OAASyD,IAAUvK,EAAU6G,aACrE4L,EAAWC,EACXF,EAAgBjI,GAIxB,GAAIiI,IAAkBxS,EAAUyH,QAAU+K,IAAkBxS,EAAUkH,WAClEsL,IAAkBxS,EAAUqH,QAAUmL,IAAkBxS,EAAUuH,QAClEiL,IAAkBxS,EAAUoH,OAAQ,CAEpC,MAAMxB,EAASmE,EAAMa,OAAS7K,EAAaA,EAAa,EAClD8F,EAASkE,EAAMc,OAAS9K,EAAaA,EAAa,EAClD+K,EAAcxC,EAAqB1C,EAAQC,EAAQxF,GACnD0K,EAAOd,EAAQ0I,mBAAmB7H,EAAa0H,EAAe5M,EAAQC,GAE5EgM,EAAOnG,KAAK,CACRuB,GAAI,UAAUlD,EAAMa,UAAUb,EAAMc,SACpCiH,KAAM/G,EACNnF,SACAC,SACA8F,KAAMuE,EAAqBsC,GAC3BP,QAAS,GACTC,QAAS,EACTC,SAAU,IAElB,CACJ,CAEA,OAAON,CACX,CAgCmBe,CAAe9I,EAAOI,EAAQH,EAAO1J,EAAM4J,GAE1D,MAAO,CACHF,QACAD,QACAI,SACA2I,aAAc,GACdhB,SACAiB,YAAaC,KAAKC,MAE1B,CAiBA,IAAIC,EAA6B,KAC7BjJ,EAAmC,KACnCC,EAAgC,KAEpC,SAASiJ,EAAc7S,GACf4S,IAAgB5S,IAChB4S,EAAc5S,EACd2J,EAAU3E,EAAuBhF,GACjC4J,EAhsBR,SAA6B5J,GACzB,MAAO,CACH2K,iBAAkBA,CAACmI,EAAOvN,EAAQC,KAC9B,MACMzD,EAAMhC,EADSuB,EAAelB,KAAKI,MAAM+E,GAASnF,KAAKI,MAAMgF,GAASxF,EAAO,OAE7E+S,EAAQ1L,EAAWyL,GAEnBE,EAAYjR,EAAI7B,OAAS,GACzB+S,EAAYlR,EAAI7B,OAAS,GAE/B,IAAIwK,EAAO,GAKX,OAJIsI,IAAWtI,GAAQ3I,EAAIV,KAAK0R,EAAMxL,WACtCmD,GAAQ3I,EAAIV,KAAK0R,EAAMvL,OACnByL,IAAWvI,GAAQ3I,EAAIV,KAAK0R,EAAMtL,WAE/BiD,EAAKwI,OAAO,GAAGC,cAAgBzI,EAAK0I,MAAM,EAAE,EAGvDd,mBAAoBA,CAACQ,EAAO5I,EAAO3E,EAAQC,KACvC,MACMzD,EAAMhC,EADSuB,EAAelB,KAAKI,MAAM+E,GAASnF,KAAKI,MAAMgF,GAASxF,EAAO,OAE7E+S,EAAQ1L,EAAWyL,GACnBO,EAAavL,EAAYoC,IAAU,CAAC,SAEpCoJ,EAAW,CACb,IAAM,OAAOvR,EAAIV,KAAK0R,EAAMxL,aAAaxF,EAAIV,KAAKgS,KAClD,IAAM,GAAGtR,EAAIV,KAAK0R,EAAMxL,YAAYxF,EAAIV,KAAK0R,EAAMvL,UAAUzF,EAAIV,KAAKgS,KACtE,IAAM,GAAGtR,EAAIV,KAAKgS,SAAkBtR,EAAIV,KAAK0R,EAAMxL,YAAYxF,EAAIV,KAAK0R,EAAMvL,UAGlF,OAAOzF,EAAIV,KAAKiS,EAATvR,EAAoB,EAGvC,CA+pBkBwR,CAAoBvT,GAEtC,CAGAwT,KAAKC,UAAaC,IACd,MAAMC,EAAUD,EAAEE,KAElB,GAAqB,SAAjBD,EAAQrI,KAGR,OAFAuH,EAAcc,EAAQ3T,WACtBwT,KAAKK,YAAY,CAAEvI,KAAM,UAI7B,GAAqB,aAAjBqI,EAAQrI,KAAqB,CAC7BuH,EAAcc,EAAQ3T,MAEtB,MAAM8T,EAAQ9D,EACV,CAAEzF,OAAQoJ,EAAQpJ,OAAQC,OAAQmJ,EAAQnJ,QAC1CmJ,EAAQ3T,KACR2J,EACAC,GAGJ4J,KAAKK,YAAY,CACbvI,KAAM,QACNf,OAAQoJ,EAAQpJ,OAChBC,OAAQmJ,EAAQnJ,OAChBsJ,SAER,E","sources":["tools/world-explorer/workers/ChunkWorker.ts"],"sourcesContent":["// Web Worker for chunk generation\r\n// This file is self-contained with all dependencies inlined\r\n\r\ndeclare const self: DedicatedWorkerGlobalScope;\r\n\r\n// ============= Types (from ChunkTypes.ts) =============\r\nconst CHUNK_SIZE = 64;\r\n\r\nenum BiomeType {\r\n    DEEP_OCEAN,\r\n    OCEAN,\r\n    COASTAL_WATER,\r\n    BEACH,\r\n    PLAINS,\r\n    FOREST,\r\n    JUNGLE,\r\n    DESERT,\r\n    HILLS,\r\n    MOUNTAINS,\r\n    SNOW_PEAKS,\r\n    TUNDRA,\r\n    SWAMP,\r\n    LAKE,\r\n    RIVER\r\n}\r\n\r\nenum RoadType {\r\n    NONE,\r\n    DIRT,\r\n    PAVED,\r\n    RAIL\r\n}\r\n\r\nenum LabelType {\r\n    CITY,\r\n    TOWN,\r\n    VILLAGE,\r\n    REGION,\r\n    MOUNTAIN,\r\n    MOUNTAIN_RANGE,\r\n    LAKE,\r\n    RIVER,\r\n    SEA,\r\n    OCEAN,\r\n    FOREST,\r\n    DESERT\r\n}\r\n\r\nenum RegionStyle {\r\n    NORDIC,\r\n    CELTIC,\r\n    LATIN,\r\n    DESERT,\r\n    EASTERN,\r\n    FANTASY\r\n}\r\n\r\ninterface Tile {\r\n    elevation: number;\r\n    moisture: number;\r\n    temperature: number;\r\n    biome: BiomeType;\r\n    riverStrength: number;\r\n    roadType: RoadType;\r\n    cityId?: string;\r\n}\r\n\r\ninterface WorldCoordinate {\r\n    worldX: number;\r\n    worldY: number;\r\n}\r\n\r\ninterface ChunkCoordinate {\r\n    chunkX: number;\r\n    chunkY: number;\r\n}\r\n\r\ninterface Street {\r\n    type: 'main' | 'secondary' | 'alley';\r\n    points: WorldCoordinate[];\r\n}\r\n\r\ninterface Building {\r\n    id: string;\r\n    footprint: WorldCoordinate[];\r\n    height: number;\r\n}\r\n\r\ninterface City {\r\n    id: string;\r\n    name: string;\r\n    centerX: number;\r\n    centerY: number;\r\n    radius: number;\r\n    population: number;\r\n    regionStyle: RegionStyle;\r\n    streets: Street[];\r\n    buildings: Building[];\r\n}\r\n\r\ninterface RoadSegment {\r\n    type: RoadType;\r\n    path: WorldCoordinate[];\r\n    fromCityId: string;\r\n    toCityId: string;\r\n}\r\n\r\ninterface Label {\r\n    id: string;\r\n    text: string;\r\n    worldX: number;\r\n    worldY: number;\r\n    type: LabelType;\r\n    minZoom: number;\r\n    maxZoom: number;\r\n    fontSize: number;\r\n    rotation?: number;\r\n}\r\n\r\ninterface Chunk {\r\n    coord: ChunkCoordinate;\r\n    tiles: Tile[][];\r\n    cities: City[];\r\n    roadSegments: RoadSegment[];\r\n    labels: Label[];\r\n    generatedAt: number;\r\n}\r\n\r\n// ============= SeededRandom =============\r\ninterface SeededRandom {\r\n    next: () => number;\r\n    nextInt: (max: number) => number;\r\n    nextRange: (min: number, max: number) => number;\r\n    nextBool: (probability?: number) => boolean;\r\n    shuffle: <T>(array: T[]) => T[];\r\n    pick: <T>(array: T[]) => T;\r\n}\r\n\r\nfunction createSeededRandom(seed: number): SeededRandom {\r\n    let state = seed >>> 0;\r\n\r\n    function next(): number {\r\n        state |= 0;\r\n        state = (state + 0x6D2B79F5) | 0;\r\n        let t = Math.imul(state ^ (state >>> 15), 1 | state);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    }\r\n\r\n    return {\r\n        next,\r\n        nextInt: (max) => Math.floor(next() * max),\r\n        nextRange: (min, max) => min + next() * (max - min),\r\n        nextBool: (probability = 0.5) => next() < probability,\r\n        shuffle: <T>(array: T[]): T[] => {\r\n            const result = [...array];\r\n            for (let i = result.length - 1; i > 0; i--) {\r\n                const j = Math.floor(next() * (i + 1));\r\n                [result[i], result[j]] = [result[j], result[i]];\r\n            }\r\n            return result;\r\n        },\r\n        pick: <T>(array: T[]): T => array[Math.floor(next() * array.length)]\r\n    };\r\n}\r\n\r\nfunction hashCoordinate(x: number, y: number, seed: number): number {\r\n    let hash = seed;\r\n    hash = Math.imul(hash ^ (x | 0), 0x85ebca6b);\r\n    hash = Math.imul(hash ^ (y | 0), 0xc2b2ae35);\r\n    hash ^= hash >>> 16;\r\n    return hash >>> 0;\r\n}\r\n\r\n// ============= Noise =============\r\nconst GRAD3: [number, number][] = [\r\n    [1, 1], [-1, 1], [1, -1], [-1, -1],\r\n    [1, 0], [-1, 0], [0, 1], [0, -1]\r\n];\r\n\r\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\r\nconst G2 = (3 - Math.sqrt(3)) / 6;\r\n\r\ninterface NoiseGenerator {\r\n    noise2D: (x: number, y: number) => number;\r\n    octaveNoise2D: (x: number, y: number, octaves: number, persistence: number, lacunarity: number) => number;\r\n    ridgedNoise2D: (x: number, y: number, octaves: number, persistence: number, lacunarity: number) => number;\r\n}\r\n\r\nfunction createNoiseGenerator(seed: number): NoiseGenerator {\r\n    const rng = createSeededRandom(seed);\r\n    const perm: number[] = [];\r\n    const permMod8: number[] = [];\r\n\r\n    for (let i = 0; i < 256; i++) {\r\n        perm[i] = i;\r\n    }\r\n\r\n    for (let i = 255; i > 0; i--) {\r\n        const j = rng.nextInt(i + 1);\r\n        [perm[i], perm[j]] = [perm[j], perm[i]];\r\n    }\r\n\r\n    for (let i = 0; i < 512; i++) {\r\n        perm[i] = perm[i & 255];\r\n        permMod8[i] = perm[i] & 7;\r\n    }\r\n\r\n    function dot2(gx: number, gy: number, x: number, y: number): number {\r\n        return gx * x + gy * y;\r\n    }\r\n\r\n    function noise2D(x: number, y: number): number {\r\n        const s = (x + y) * F2;\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n\r\n        const t = (i + j) * G2;\r\n        const X0 = i - t;\r\n        const Y0 = j - t;\r\n        const x0 = x - X0;\r\n        const y0 = y - Y0;\r\n\r\n        let i1: number, j1: number;\r\n        if (x0 > y0) {\r\n            i1 = 1;\r\n            j1 = 0;\r\n        } else {\r\n            i1 = 0;\r\n            j1 = 1;\r\n        }\r\n\r\n        const x1 = x0 - i1 + G2;\r\n        const y1 = y0 - j1 + G2;\r\n        const x2 = x0 - 1 + 2 * G2;\r\n        const y2 = y0 - 1 + 2 * G2;\r\n\r\n        const ii = i & 255;\r\n        const jj = j & 255;\r\n\r\n        let n0 = 0, n1 = 0, n2 = 0;\r\n\r\n        let t0 = 0.5 - x0 * x0 - y0 * y0;\r\n        if (t0 >= 0) {\r\n            t0 *= t0;\r\n            const gi0 = permMod8[ii + perm[jj]];\r\n            const [gx0, gy0] = GRAD3[gi0];\r\n            n0 = t0 * t0 * dot2(gx0, gy0, x0, y0);\r\n        }\r\n\r\n        let t1 = 0.5 - x1 * x1 - y1 * y1;\r\n        if (t1 >= 0) {\r\n            t1 *= t1;\r\n            const gi1 = permMod8[ii + i1 + perm[jj + j1]];\r\n            const [gx1, gy1] = GRAD3[gi1];\r\n            n1 = t1 * t1 * dot2(gx1, gy1, x1, y1);\r\n        }\r\n\r\n        let t2 = 0.5 - x2 * x2 - y2 * y2;\r\n        if (t2 >= 0) {\r\n            t2 *= t2;\r\n            const gi2 = permMod8[ii + 1 + perm[jj + 1]];\r\n            const [gx2, gy2] = GRAD3[gi2];\r\n            n2 = t2 * t2 * dot2(gx2, gy2, x2, y2);\r\n        }\r\n\r\n        return 70 * (n0 + n1 + n2);\r\n    }\r\n\r\n    function octaveNoise2D(x: number, y: number, octaves: number, persistence: number, lacunarity: number): number {\r\n        let total = 0;\r\n        let amplitude = 1;\r\n        let frequency = 1;\r\n        let maxValue = 0;\r\n\r\n        for (let i = 0; i < octaves; i++) {\r\n            total += noise2D(x * frequency, y * frequency) * amplitude;\r\n            maxValue += amplitude;\r\n            amplitude *= persistence;\r\n            frequency *= lacunarity;\r\n        }\r\n\r\n        return total / maxValue;\r\n    }\r\n\r\n    function ridgedNoise2D(x: number, y: number, octaves: number, persistence: number, lacunarity: number): number {\r\n        let total = 0;\r\n        let amplitude = 1;\r\n        let frequency = 1;\r\n        let maxValue = 0;\r\n\r\n        for (let i = 0; i < octaves; i++) {\r\n            const n = 1 - Math.abs(noise2D(x * frequency, y * frequency));\r\n            total += n * n * amplitude;\r\n            maxValue += amplitude;\r\n            amplitude *= persistence;\r\n            frequency *= lacunarity;\r\n        }\r\n\r\n        return total / maxValue;\r\n    }\r\n\r\n    return { noise2D, octaveNoise2D, ridgedNoise2D };\r\n}\r\n\r\n// ============= TerrainGenerator =============\r\nconst CONTINENT_SCALE = 0.002;\r\nconst MOUNTAIN_SCALE = 0.015;\r\nconst DETAIL_SCALE = 0.08;\r\nconst MOISTURE_SCALE = 0.01;\r\nconst TEMP_SCALE = 0.005;\r\n\r\ninterface TerrainGenerator {\r\n    getElevation: (worldX: number, worldY: number) => number;\r\n    getMoisture: (worldX: number, worldY: number) => number;\r\n    getTemperature: (worldX: number, worldY: number) => number;\r\n}\r\n\r\nfunction createTerrainGenerator(seed: number): TerrainGenerator {\r\n    const elevationNoise = createNoiseGenerator(seed);\r\n    const mountainNoise = createNoiseGenerator(seed + 1000);\r\n    const detailNoise = createNoiseGenerator(seed + 2000);\r\n    const moistureNoise = createNoiseGenerator(seed + 3000);\r\n    const temperatureNoise = createNoiseGenerator(seed + 4000);\r\n\r\n    function smoothstep(edge0: number, edge1: number, x: number): number {\r\n        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));\r\n        return t * t * (3 - 2 * t);\r\n    }\r\n\r\n    return {\r\n        getElevation: (worldX, worldY) => {\r\n            const continent = elevationNoise.octaveNoise2D(\r\n                worldX * CONTINENT_SCALE, worldY * CONTINENT_SCALE, 4, 0.5, 2.0\r\n            );\r\n            const mountains = mountainNoise.ridgedNoise2D(\r\n                worldX * MOUNTAIN_SCALE, worldY * MOUNTAIN_SCALE, 4, 0.5, 2.0\r\n            );\r\n            const detail = detailNoise.octaveNoise2D(\r\n                worldX * DETAIL_SCALE, worldY * DETAIL_SCALE, 3, 0.5, 2.0\r\n            ) * 0.15;\r\n\r\n            const landMask = smoothstep(-0.1, 0.2, continent);\r\n            const baseElevation = continent * 0.4;\r\n            const mountainContribution = mountains * 0.5 * landMask;\r\n\r\n            return baseElevation + mountainContribution + detail;\r\n        },\r\n\r\n        getMoisture: (worldX, worldY) => {\r\n            const noise = moistureNoise.octaveNoise2D(\r\n                worldX * MOISTURE_SCALE, worldY * MOISTURE_SCALE, 4, 0.5, 2.0\r\n            );\r\n            return noise * 0.5 + 0.5;\r\n        },\r\n\r\n        getTemperature: (worldX, worldY) => {\r\n            const latitudeEffect = Math.cos(worldY * 0.003) * 0.4 + 0.5;\r\n            const noiseEffect = temperatureNoise.octaveNoise2D(\r\n                worldX * TEMP_SCALE, worldY * TEMP_SCALE, 3, 0.5, 2.0\r\n            ) * 0.2;\r\n            return Math.max(0, Math.min(1, latitudeEffect + noiseEffect));\r\n        }\r\n    };\r\n}\r\n\r\n// ============= BiomeClassifier =============\r\nfunction classifyBiome(elevation: number, moisture: number, temperature: number): BiomeType {\r\n    if (elevation < -0.3) return BiomeType.DEEP_OCEAN;\r\n    if (elevation < -0.15) return BiomeType.OCEAN;\r\n    if (elevation < -0.05) return BiomeType.COASTAL_WATER;\r\n    if (elevation < 0.02) return BiomeType.BEACH;\r\n\r\n    if (elevation > 0.55) return BiomeType.SNOW_PEAKS;\r\n    if (elevation > 0.4) return BiomeType.MOUNTAINS;\r\n    if (elevation > 0.25) return BiomeType.HILLS;\r\n\r\n    if (temperature < 0.25) return BiomeType.TUNDRA;\r\n\r\n    if (moisture < 0.25) return BiomeType.DESERT;\r\n\r\n    if (moisture < 0.4) {\r\n        if (temperature > 0.6) return BiomeType.DESERT;\r\n        return BiomeType.PLAINS;\r\n    }\r\n\r\n    if (moisture > 0.7) {\r\n        if (temperature > 0.65) return BiomeType.JUNGLE;\r\n        if (temperature < 0.35) return BiomeType.SWAMP;\r\n        return BiomeType.FOREST;\r\n    }\r\n\r\n    if (moisture > 0.5) {\r\n        if (temperature > 0.6) return BiomeType.JUNGLE;\r\n        return BiomeType.FOREST;\r\n    }\r\n\r\n    return BiomeType.PLAINS;\r\n}\r\n\r\nfunction isCitySuitable(biome: BiomeType): boolean {\r\n    return biome === BiomeType.PLAINS ||\r\n           biome === BiomeType.FOREST ||\r\n           biome === BiomeType.HILLS ||\r\n           biome === BiomeType.BEACH;\r\n}\r\n\r\n// ============= NameGenerator =============\r\ninterface NameParts {\r\n    prefixes: string[];\r\n    roots: string[];\r\n    suffixes: string[];\r\n}\r\n\r\nconst NAME_PARTS: Record<RegionStyle, NameParts> = {\r\n    [RegionStyle.NORDIC]: {\r\n        prefixes: ['Thor', 'Frost', 'Iron', 'Storm', 'Wolf', 'Raven', 'Snow', 'Ice', 'Stone', 'Bear'],\r\n        roots: ['heim', 'gard', 'fjord', 'vik', 'dal', 'berg', 'holm', 'vang', 'fell', 'mark'],\r\n        suffixes: ['en', '', 'stad', 'by', 'ness']\r\n    },\r\n    [RegionStyle.CELTIC]: {\r\n        prefixes: ['Dun', 'Glen', 'Bally', 'Kin', 'Strath', 'Aber', 'Kil', 'Loch', 'Ben', 'Cairn'],\r\n        roots: ['more', 'derry', 'bridge', 'ford', 'wick', 'ton', 'wood', 'field', 'vale', 'moor'],\r\n        suffixes: ['', 'ey', 'ie', 'ach', 'an']\r\n    },\r\n    [RegionStyle.LATIN]: {\r\n        prefixes: ['Port', 'Villa', 'Monte', 'Bella', 'Alta', 'Nova', 'Santa', 'San', 'Rio', 'Terra'],\r\n        roots: ['vista', 'mare', 'rosa', 'verde', 'luna', 'sol', 'oro', 'plata', 'cruz', 'piedra'],\r\n        suffixes: ['', 'ia', 'um', 'ino', 'ero']\r\n    },\r\n    [RegionStyle.DESERT]: {\r\n        prefixes: ['Al', 'El', 'Kas', 'Dar', 'Bab', 'Wadi', 'Oum', 'Ain', 'Jebel', 'Ras'],\r\n        roots: ['rashid', 'salem', 'qadir', 'malik', 'hamid', 'kareem', 'zahir', 'nadir', 'farid', 'jamil'],\r\n        suffixes: ['', 'a', 'i', 'abad', 'stan']\r\n    },\r\n    [RegionStyle.EASTERN]: {\r\n        prefixes: ['Jade', 'Golden', 'Silver', 'Dragon', 'Phoenix', 'Moon', 'Sun', 'Cloud', 'Misty', 'Crane'],\r\n        roots: ['peak', 'river', 'gate', 'bridge', 'garden', 'temple', 'spring', 'lake', 'forest', 'mountain'],\r\n        suffixes: ['', ' Valley', ' Heights', ' Crossing', '']\r\n    },\r\n    [RegionStyle.FANTASY]: {\r\n        prefixes: ['Shadow', 'Crystal', 'Silver', 'Ember', 'Thorn', 'Mist', 'Star', 'Dawn', 'Dusk', 'Rune'],\r\n        roots: ['mere', 'vale', 'spire', 'haven', 'hold', 'gate', 'wood', 'glade', 'keep', 'reach'],\r\n        suffixes: ['', 'shire', 'land', 'fell', 'dale']\r\n    }\r\n};\r\n\r\nconst BIOME_WORDS: Record<BiomeType, string[]> = {\r\n    [BiomeType.DEEP_OCEAN]: ['Abyss', 'Depths', 'Deep'],\r\n    [BiomeType.OCEAN]: ['Sea', 'Waters', 'Ocean'],\r\n    [BiomeType.COASTAL_WATER]: ['Bay', 'Gulf', 'Strait'],\r\n    [BiomeType.BEACH]: ['Shore', 'Coast', 'Strand'],\r\n    [BiomeType.PLAINS]: ['Plains', 'Grasslands', 'Steppes', 'Prairie'],\r\n    [BiomeType.FOREST]: ['Forest', 'Woods', 'Woodland', 'Grove'],\r\n    [BiomeType.JUNGLE]: ['Jungle', 'Rainforest', 'Wilds'],\r\n    [BiomeType.DESERT]: ['Desert', 'Wastes', 'Sands', 'Dunes'],\r\n    [BiomeType.HILLS]: ['Hills', 'Highlands', 'Downs'],\r\n    [BiomeType.MOUNTAINS]: ['Mountains', 'Peaks', 'Range', 'Heights'],\r\n    [BiomeType.SNOW_PEAKS]: ['Frostpeaks', 'Snowcaps', 'Icepeaks'],\r\n    [BiomeType.TUNDRA]: ['Tundra', 'Wastes', 'Barrens', 'Expanse'],\r\n    [BiomeType.SWAMP]: ['Swamp', 'Marsh', 'Bog', 'Mire'],\r\n    [BiomeType.LAKE]: ['Lake', 'Loch', 'Mere'],\r\n    [BiomeType.RIVER]: ['River', 'Stream', 'Waters']\r\n};\r\n\r\ninterface NameGenerator {\r\n    generateCityName: (style: RegionStyle, worldX: number, worldY: number) => string;\r\n    generateRegionName: (style: RegionStyle, biome: BiomeType, worldX: number, worldY: number) => string;\r\n}\r\n\r\nfunction createNameGenerator(seed: number): NameGenerator {\r\n    return {\r\n        generateCityName: (style, worldX, worldY) => {\r\n            const locationSeed = hashCoordinate(Math.floor(worldX), Math.floor(worldY), seed + 7919);\r\n            const rng = createSeededRandom(locationSeed);\r\n            const parts = NAME_PARTS[style];\r\n\r\n            const usePrefix = rng.next() < 0.7;\r\n            const useSuffix = rng.next() < 0.5;\r\n\r\n            let name = '';\r\n            if (usePrefix) name += rng.pick(parts.prefixes);\r\n            name += rng.pick(parts.roots);\r\n            if (useSuffix) name += rng.pick(parts.suffixes);\r\n\r\n            return name.charAt(0).toUpperCase() + name.slice(1);\r\n        },\r\n\r\n        generateRegionName: (style, biome, worldX, worldY) => {\r\n            const locationSeed = hashCoordinate(Math.floor(worldX), Math.floor(worldY), seed + 8923);\r\n            const rng = createSeededRandom(locationSeed);\r\n            const parts = NAME_PARTS[style];\r\n            const biomeWords = BIOME_WORDS[biome] || ['Lands'];\r\n\r\n            const patterns = [\r\n                () => `The ${rng.pick(parts.prefixes)} ${rng.pick(biomeWords)}`,\r\n                () => `${rng.pick(parts.prefixes)}${rng.pick(parts.roots)} ${rng.pick(biomeWords)}`,\r\n                () => `${rng.pick(biomeWords)} of ${rng.pick(parts.prefixes)}${rng.pick(parts.roots)}`\r\n            ];\r\n\r\n            return rng.pick(patterns)();\r\n        }\r\n    };\r\n}\r\n\r\n// ============= WorldGenerator (chunk generation) =============\r\nfunction determineRegionStyle(worldX: number, worldY: number, seed: number): RegionStyle {\r\n    const regionNoise = hashCoordinate(Math.floor(worldX / 500), Math.floor(worldY / 500), seed + 8000);\r\n    const styles = [\r\n        RegionStyle.NORDIC, RegionStyle.CELTIC, RegionStyle.LATIN,\r\n        RegionStyle.DESERT, RegionStyle.EASTERN, RegionStyle.FANTASY\r\n    ];\r\n    return styles[regionNoise % styles.length];\r\n}\r\n\r\nfunction generateRivers(tiles: Tile[][], coord: ChunkCoordinate, seed: number, terrain: TerrainGenerator): void {\r\n    const riverSeed = hashCoordinate(coord.chunkX, coord.chunkY, seed + 5000);\r\n    const rng = createSeededRandom(riverSeed);\r\n\r\n    if (rng.next() > 0.15) return;\r\n\r\n    let highestElevation = -1;\r\n    let highestX = 0;\r\n    let highestY = 0;\r\n\r\n    for (let y = 0; y < CHUNK_SIZE; y++) {\r\n        for (let x = 0; x < CHUNK_SIZE; x++) {\r\n            const tile = tiles[y][x];\r\n            if (tile.elevation > 0.3 && tile.elevation > highestElevation) {\r\n                highestElevation = tile.elevation;\r\n                highestX = x;\r\n                highestY = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (highestElevation < 0.3) return;\r\n\r\n    let x = highestX;\r\n    let y = highestY;\r\n    let iterations = 0;\r\n    const maxIterations = CHUNK_SIZE * 2;\r\n\r\n    while (iterations < maxIterations) {\r\n        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE) break;\r\n\r\n        const tile = tiles[y][x];\r\n        if (tile.biome === BiomeType.OCEAN || tile.biome === BiomeType.DEEP_OCEAN || tile.biome === BiomeType.COASTAL_WATER) {\r\n            break;\r\n        }\r\n\r\n        tile.riverStrength = Math.min(1, tile.riverStrength + 0.3 + iterations * 0.02);\r\n        if (tile.biome !== BiomeType.RIVER && tile.riverStrength > 0.5) {\r\n            tile.biome = BiomeType.RIVER;\r\n        }\r\n\r\n        let lowestElevation = tile.elevation;\r\n        let nextX = x;\r\n        let nextY = y;\r\n\r\n        const neighbors = [\r\n            [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1],\r\n            [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1], [x + 1, y + 1]\r\n        ];\r\n\r\n        for (const [nx, ny] of neighbors) {\r\n            if (nx >= 0 && nx < CHUNK_SIZE && ny >= 0 && ny < CHUNK_SIZE) {\r\n                const neighborTile = tiles[ny][nx];\r\n                if (neighborTile.elevation < lowestElevation) {\r\n                    lowestElevation = neighborTile.elevation;\r\n                    nextX = nx;\r\n                    nextY = ny;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextX === x && nextY === y) break;\r\n\r\n        x = nextX;\r\n        y = nextY;\r\n        iterations++;\r\n    }\r\n}\r\n\r\nfunction clipLineToCircle(\r\n    x1: number, y1: number, x2: number, y2: number,\r\n    cx: number, cy: number, r: number\r\n): { worldX: number; worldY: number }[] | null {\r\n    const dx = x2 - x1;\r\n    const dy = y2 - y1;\r\n    const len = Math.sqrt(dx * dx + dy * dy);\r\n    if (len < 0.1) return null;\r\n\r\n    const fx = x1 - cx;\r\n    const fy = y1 - cy;\r\n    const a = dx * dx + dy * dy;\r\n    const b = 2 * (fx * dx + fy * dy);\r\n    const c = fx * fx + fy * fy - r * r;\r\n    const discriminant = b * b - 4 * a * c;\r\n\r\n    if (discriminant < 0) return null;\r\n\r\n    const sqrtD = Math.sqrt(discriminant);\r\n    const t1 = (-b - sqrtD) / (2 * a);\r\n    const t2 = (-b + sqrtD) / (2 * a);\r\n\r\n    if (t2 < 0 || t1 > 1) return null;\r\n\r\n    const clampedT1 = Math.max(0, t1);\r\n    const clampedT2 = Math.min(1, t2);\r\n\r\n    return [\r\n        { worldX: x1 + dx * clampedT1, worldY: y1 + dy * clampedT1 },\r\n        { worldX: x1 + dx * clampedT2, worldY: y1 + dy * clampedT2 }\r\n    ];\r\n}\r\n\r\nfunction generateCityStreets(centerX: number, centerY: number, radius: number, rng: SeededRandom): Street[] {\r\n    const streets: Street[] = [];\r\n    const isRadial = rng.next() < 0.4;\r\n\r\n    if (isRadial) {\r\n        const numRadials = 4 + Math.floor(rng.next() * 4);\r\n        for (let i = 0; i < numRadials; i++) {\r\n            const angle = (i / numRadials) * Math.PI * 2 + rng.next() * 0.2;\r\n            streets.push({\r\n                type: 'main',\r\n                points: [\r\n                    { worldX: centerX, worldY: centerY },\r\n                    { worldX: centerX + Math.cos(angle) * radius * 0.95, worldY: centerY + Math.sin(angle) * radius * 0.95 }\r\n                ]\r\n            });\r\n        }\r\n\r\n        const numRings = Math.floor(radius / 4);\r\n        for (let r = 1; r <= numRings; r++) {\r\n            const ringRadius = (r / numRings) * radius * 0.8;\r\n            const segments = 16;\r\n            const points: { worldX: number; worldY: number }[] = [];\r\n            for (let i = 0; i <= segments; i++) {\r\n                const angle = (i / segments) * Math.PI * 2;\r\n                points.push({ worldX: centerX + Math.cos(angle) * ringRadius, worldY: centerY + Math.sin(angle) * ringRadius });\r\n            }\r\n            streets.push({ type: 'secondary', points });\r\n        }\r\n    } else {\r\n        const gridSpacing = 1.5 + rng.next() * 1;\r\n        const gridAngle = rng.next() * Math.PI / 6;\r\n        const cosA = Math.cos(gridAngle);\r\n        const sinA = Math.sin(gridAngle);\r\n\r\n        for (let offset = -radius; offset <= radius; offset += gridSpacing) {\r\n            const startX = centerX + offset * cosA - radius * sinA;\r\n            const startY = centerY + offset * sinA + radius * cosA;\r\n            const endX = centerX + offset * cosA + radius * sinA;\r\n            const endY = centerY + offset * sinA - radius * cosA;\r\n\r\n            const points = clipLineToCircle(startX, startY, endX, endY, centerX, centerY, radius * 0.9);\r\n            if (points) {\r\n                streets.push({ type: Math.abs(offset) < gridSpacing ? 'main' : 'secondary', points });\r\n            }\r\n        }\r\n\r\n        for (let offset = -radius; offset <= radius; offset += gridSpacing) {\r\n            const startX = centerX + offset * sinA + radius * cosA;\r\n            const startY = centerY - offset * cosA + radius * sinA;\r\n            const endX = centerX + offset * sinA - radius * cosA;\r\n            const endY = centerY - offset * cosA - radius * sinA;\r\n\r\n            const points = clipLineToCircle(startX, startY, endX, endY, centerX, centerY, radius * 0.9);\r\n            if (points) {\r\n                streets.push({ type: Math.abs(offset) < gridSpacing ? 'main' : 'secondary', points });\r\n            }\r\n        }\r\n    }\r\n\r\n    return streets;\r\n}\r\n\r\nfunction pointToLineDistance(px: number, py: number, x1: number, y1: number, x2: number, y2: number): number {\r\n    const dx = x2 - x1;\r\n    const dy = y2 - y1;\r\n    const len2 = dx * dx + dy * dy;\r\n\r\n    if (len2 < 0.0001) {\r\n        return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);\r\n    }\r\n\r\n    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / len2));\r\n    const nearX = x1 + t * dx;\r\n    const nearY = y1 + t * dy;\r\n\r\n    return Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2);\r\n}\r\n\r\nfunction generateCityBuildings(centerX: number, centerY: number, radius: number, streets: Street[], rng: SeededRandom): Building[] {\r\n    const buildings: Building[] = [];\r\n    const buildingDensity = 0.3 + rng.next() * 0.3;\r\n    const gridStep = 0.4;\r\n\r\n    for (let dy = -radius; dy < radius; dy += gridStep) {\r\n        for (let dx = -radius; dx < radius; dx += gridStep) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist > radius * 0.85) continue;\r\n\r\n            if (rng.next() > buildingDensity) continue;\r\n\r\n            const bx = centerX + dx + (rng.next() - 0.5) * 0.2;\r\n            const by = centerY + dy + (rng.next() - 0.5) * 0.2;\r\n\r\n            let tooCloseToStreet = false;\r\n            for (const street of streets) {\r\n                for (let i = 0; i < street.points.length - 1; i++) {\r\n                    const p1 = street.points[i];\r\n                    const p2 = street.points[i + 1];\r\n                    const distToStreet = pointToLineDistance(bx, by, p1.worldX, p1.worldY, p2.worldX, p2.worldY);\r\n                    if (distToStreet < 0.3) {\r\n                        tooCloseToStreet = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (tooCloseToStreet) break;\r\n            }\r\n\r\n            if (tooCloseToStreet) continue;\r\n\r\n            const width = 0.15 + rng.next() * 0.2;\r\n            const height = 0.15 + rng.next() * 0.2;\r\n\r\n            buildings.push({\r\n                id: `building_${bx.toFixed(2)}_${by.toFixed(2)}`,\r\n                footprint: [\r\n                    { worldX: bx - width / 2, worldY: by - height / 2 },\r\n                    { worldX: bx + width / 2, worldY: by - height / 2 },\r\n                    { worldX: bx + width / 2, worldY: by + height / 2 },\r\n                    { worldX: bx - width / 2, worldY: by + height / 2 }\r\n                ],\r\n                height: 1 + rng.next() * 3\r\n            });\r\n        }\r\n    }\r\n\r\n    return buildings;\r\n}\r\n\r\nfunction generateCities(\r\n    tiles: Tile[][], coord: ChunkCoordinate, seed: number,\r\n    rng: SeededRandom, terrain: TerrainGenerator, nameGen: NameGenerator\r\n): City[] {\r\n    const cities: City[] = [];\r\n\r\n    if (rng.next() > 0.08) return cities;\r\n\r\n    let bestScore = 0;\r\n    let bestX = CHUNK_SIZE / 2;\r\n    let bestY = CHUNK_SIZE / 2;\r\n\r\n    for (let y = 8; y < CHUNK_SIZE - 8; y += 8) {\r\n        for (let x = 8; x < CHUNK_SIZE - 8; x += 8) {\r\n            const tile = tiles[y][x];\r\n            if (!isCitySuitable(tile.biome)) continue;\r\n\r\n            let score = 1;\r\n            score += (1 - Math.abs(tile.elevation - 0.1)) * 2;\r\n            score += (1 - Math.abs(tile.moisture - 0.5)) * 1.5;\r\n\r\n            for (let dy = -5; dy <= 5; dy++) {\r\n                for (let dx = -5; dx <= 5; dx++) {\r\n                    const ny = y + dy;\r\n                    const nx = x + dx;\r\n                    if (ny >= 0 && ny < CHUNK_SIZE && nx >= 0 && nx < CHUNK_SIZE) {\r\n                        const nearTile = tiles[ny][nx];\r\n                        if (nearTile.biome === BiomeType.RIVER || nearTile.biome === BiomeType.COASTAL_WATER) {\r\n                            score += 0.5;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (score > bestScore) {\r\n                bestScore = score;\r\n                bestX = x;\r\n                bestY = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (bestScore < 2) return cities;\r\n\r\n    const worldX = coord.chunkX * CHUNK_SIZE + bestX;\r\n    const worldY = coord.chunkY * CHUNK_SIZE + bestY;\r\n    const regionStyle = determineRegionStyle(worldX, worldY, seed);\r\n    const name = nameGen.generateCityName(regionStyle, worldX, worldY);\r\n    const population = Math.floor(500 + rng.next() * 50000);\r\n    const radius = 3 + Math.sqrt(population / 1000);\r\n\r\n    const cityRng = createSeededRandom(hashCoordinate(worldX, worldY, seed + 6000));\r\n    const streets = generateCityStreets(worldX, worldY, radius, cityRng);\r\n    const buildings = generateCityBuildings(worldX, worldY, radius, streets, cityRng);\r\n\r\n    const city: City = {\r\n        id: `city_${worldX}_${worldY}`,\r\n        name,\r\n        centerX: worldX,\r\n        centerY: worldY,\r\n        radius,\r\n        population,\r\n        regionStyle,\r\n        streets,\r\n        buildings\r\n    };\r\n\r\n    cities.push(city);\r\n\r\n    for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {\r\n        for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= radius) {\r\n                const ty = bestY + dy;\r\n                const tx = bestX + dx;\r\n                if (ty >= 0 && ty < CHUNK_SIZE && tx >= 0 && tx < CHUNK_SIZE) {\r\n                    tiles[ty][tx].cityId = city.id;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return cities;\r\n}\r\n\r\nfunction traceHighway(\r\n    tiles: Tile[][], position: number, direction: 'horizontal' | 'vertical',\r\n    coord: ChunkCoordinate, _seed: number, terrain: TerrainGenerator\r\n): void {\r\n    const chunkWorldX = coord.chunkX * CHUNK_SIZE;\r\n    const chunkWorldY = coord.chunkY * CHUNK_SIZE;\r\n\r\n    let offset = 0;\r\n    const maxOffset = 15;\r\n\r\n    for (let i = 0; i < CHUNK_SIZE; i++) {\r\n        let bestOffset = offset;\r\n        let bestElevation = -999;\r\n\r\n        for (let tryOffset = -maxOffset; tryOffset <= maxOffset; tryOffset++) {\r\n            let x: number, y: number;\r\n            let worldX: number, worldY: number;\r\n\r\n            if (direction === 'vertical') {\r\n                x = position + tryOffset;\r\n                y = i;\r\n            } else {\r\n                x = i;\r\n                y = position + tryOffset;\r\n            }\r\n\r\n            if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE) continue;\r\n\r\n            worldX = chunkWorldX + x;\r\n            worldY = chunkWorldY + y;\r\n\r\n            const elevation = terrain.getElevation(worldX, worldY);\r\n            if (elevation < -0.05 || elevation > 0.45) continue;\r\n\r\n            const score = -Math.abs(tryOffset) * 0.1 - Math.abs(elevation - 0.1);\r\n            if (score > bestElevation) {\r\n                bestElevation = score;\r\n                bestOffset = tryOffset;\r\n            }\r\n        }\r\n\r\n        if (bestElevation > -999) {\r\n            offset = bestOffset;\r\n\r\n            let x: number, y: number;\r\n            if (direction === 'vertical') {\r\n                x = Math.max(0, Math.min(CHUNK_SIZE - 1, position + offset));\r\n                y = i;\r\n            } else {\r\n                x = i;\r\n                y = Math.max(0, Math.min(CHUNK_SIZE - 1, position + offset));\r\n            }\r\n\r\n            const tile = tiles[y]?.[x];\r\n            if (tile && tile.roadType !== RoadType.RAIL) {\r\n                tile.roadType = RoadType.PAVED;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction pathfindRoad(\r\n    tiles: Tile[][], startX: number, startY: number, endX: number, endY: number,\r\n    terrain: TerrainGenerator, coord: ChunkCoordinate, roadType: RoadType\r\n): void {\r\n    const chunkWorldX = coord.chunkX * CHUNK_SIZE;\r\n    const chunkWorldY = coord.chunkY * CHUNK_SIZE;\r\n\r\n    interface Node {\r\n        x: number; y: number; g: number; h: number; f: number; parent: Node | null;\r\n    }\r\n\r\n    const openSet: Node[] = [];\r\n    const closedSet = new Set<string>();\r\n\r\n    const startNode: Node = {\r\n        x: startX, y: startY, g: 0,\r\n        h: Math.abs(endX - startX) + Math.abs(endY - startY),\r\n        f: Math.abs(endX - startX) + Math.abs(endY - startY),\r\n        parent: null\r\n    };\r\n    openSet.push(startNode);\r\n\r\n    const maxIterations = 500;\r\n    let iterations = 0;\r\n\r\n    while (openSet.length > 0 && iterations < maxIterations) {\r\n        iterations++;\r\n\r\n        openSet.sort((a, b) => a.f - b.f);\r\n        const current = openSet.shift()!;\r\n\r\n        if (current.x === endX && current.y === endY) {\r\n            let node: Node | null = current;\r\n            while (node) {\r\n                const tile = tiles[node.y]?.[node.x];\r\n                if (tile && (tile.roadType === RoadType.NONE ||\r\n                    (roadType === RoadType.RAIL && tile.roadType !== RoadType.RAIL))) {\r\n                    tile.roadType = roadType;\r\n                }\r\n                node = node.parent;\r\n            }\r\n            return;\r\n        }\r\n\r\n        closedSet.add(`${current.x},${current.y}`);\r\n\r\n        const neighbors = [\r\n            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },\r\n            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }\r\n        ];\r\n\r\n        for (const { dx, dy } of neighbors) {\r\n            const nx = current.x + dx;\r\n            const ny = current.y + dy;\r\n\r\n            if (nx < 0 || nx >= CHUNK_SIZE || ny < 0 || ny >= CHUNK_SIZE) continue;\r\n            if (closedSet.has(`${nx},${ny}`)) continue;\r\n\r\n            const tile = tiles[ny]?.[nx];\r\n            if (!tile) continue;\r\n\r\n            const worldX = chunkWorldX + nx;\r\n            const worldY = chunkWorldY + ny;\r\n            const elevation = terrain.getElevation(worldX, worldY);\r\n\r\n            if (tile.biome === BiomeType.OCEAN || tile.biome === BiomeType.DEEP_OCEAN ||\r\n                tile.biome === BiomeType.COASTAL_WATER || tile.biome === BiomeType.LAKE ||\r\n                elevation < -0.05 || elevation > 0.45) {\r\n                continue;\r\n            }\r\n\r\n            let cost = 1;\r\n            if (elevation > 0.35) cost = 8;\r\n            else if (elevation > 0.25) cost = 3;\r\n            else if (tile.biome === BiomeType.RIVER) cost = 4;\r\n\r\n            const g = current.g + cost;\r\n            const h = Math.abs(endX - nx) + Math.abs(endY - ny);\r\n            const f = g + h;\r\n\r\n            const existing = openSet.find(n => n.x === nx && n.y === ny);\r\n            if (existing && existing.f <= f) continue;\r\n\r\n            if (existing) {\r\n                existing.g = g;\r\n                existing.h = h;\r\n                existing.f = f;\r\n                existing.parent = current;\r\n            } else {\r\n                openSet.push({ x: nx, y: ny, g, h, f, parent: current });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction generateRoads(tiles: Tile[][], cities: City[], coord: ChunkCoordinate, seed: number, terrain: TerrainGenerator): void {\r\n    const chunkWorldX = coord.chunkX * CHUNK_SIZE;\r\n    const chunkWorldY = coord.chunkY * CHUNK_SIZE;\r\n    const HIGHWAY_SPACING = 80;\r\n\r\n    const nearestHwyX = Math.round(chunkWorldX / HIGHWAY_SPACING) * HIGHWAY_SPACING;\r\n    const nearestHwyY = Math.round(chunkWorldY / HIGHWAY_SPACING) * HIGHWAY_SPACING;\r\n\r\n    for (let hwyOffset = -HIGHWAY_SPACING; hwyOffset <= HIGHWAY_SPACING + CHUNK_SIZE; hwyOffset += HIGHWAY_SPACING) {\r\n        const hwyX = nearestHwyX + hwyOffset - chunkWorldX;\r\n        if (hwyX >= -5 && hwyX < CHUNK_SIZE + 5) {\r\n            traceHighway(tiles, Math.floor(hwyX), 'vertical', coord, seed, terrain);\r\n        }\r\n\r\n        const hwyY = nearestHwyY + hwyOffset - chunkWorldY;\r\n        if (hwyY >= -5 && hwyY < CHUNK_SIZE + 5) {\r\n            traceHighway(tiles, Math.floor(hwyY), 'horizontal', coord, seed, terrain);\r\n        }\r\n    }\r\n\r\n    for (const city of cities) {\r\n        const localX = Math.floor(city.centerX - chunkWorldX);\r\n        const localY = Math.floor(city.centerY - chunkWorldY);\r\n\r\n        const nearestHwyLocalX = Math.round((city.centerX) / HIGHWAY_SPACING) * HIGHWAY_SPACING - chunkWorldX;\r\n        const nearestHwyLocalY = Math.round((city.centerY) / HIGHWAY_SPACING) * HIGHWAY_SPACING - chunkWorldY;\r\n\r\n        if (nearestHwyLocalX >= 0 && nearestHwyLocalX < CHUNK_SIZE) {\r\n            pathfindRoad(tiles, localX, localY, Math.floor(nearestHwyLocalX), localY, terrain, coord, RoadType.PAVED);\r\n        }\r\n\r\n        if (nearestHwyLocalY >= 0 && nearestHwyLocalY < CHUNK_SIZE) {\r\n            pathfindRoad(tiles, localX, localY, localX, Math.floor(nearestHwyLocalY), terrain, coord, RoadType.PAVED);\r\n        }\r\n\r\n        if (city.population > 15000) {\r\n            const railTarget = Math.abs(nearestHwyLocalX - localX) < Math.abs(nearestHwyLocalY - localY)\r\n                ? { x: Math.floor(nearestHwyLocalX), y: localY }\r\n                : { x: localX, y: Math.floor(nearestHwyLocalY) };\r\n\r\n            if (railTarget.x >= 0 && railTarget.x < CHUNK_SIZE && railTarget.y >= 0 && railTarget.y < CHUNK_SIZE) {\r\n                pathfindRoad(tiles, localX, localY, railTarget.x, railTarget.y, terrain, coord, RoadType.RAIL);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getLabelTypeForBiome(biome: BiomeType): LabelType {\r\n    switch (biome) {\r\n        case BiomeType.FOREST:\r\n        case BiomeType.JUNGLE:\r\n            return LabelType.FOREST;\r\n        case BiomeType.MOUNTAINS:\r\n        case BiomeType.SNOW_PEAKS:\r\n            return LabelType.MOUNTAIN_RANGE;\r\n        case BiomeType.DESERT:\r\n            return LabelType.DESERT;\r\n        default:\r\n            return LabelType.REGION;\r\n    }\r\n}\r\n\r\nfunction generateLabels(tiles: Tile[][], cities: City[], coord: ChunkCoordinate, seed: number, nameGen: NameGenerator): Label[] {\r\n    const labels: Label[] = [];\r\n\r\n    for (const city of cities) {\r\n        labels.push({\r\n            id: `label_${city.id}`,\r\n            text: city.name,\r\n            worldX: city.centerX,\r\n            worldY: city.centerY + city.radius + 2,\r\n            type: city.population > 10000 ? LabelType.CITY : LabelType.TOWN,\r\n            minZoom: city.population > 10000 ? 0.5 : 2,\r\n            maxZoom: 100,\r\n            fontSize: city.population > 10000 ? 14 : 11\r\n        });\r\n    }\r\n\r\n    const labelRng = createSeededRandom(hashCoordinate(coord.chunkX, coord.chunkY, seed + 9000));\r\n\r\n    if (labelRng.next() < 0.1) {\r\n        const biomeCounts = new Map<BiomeType, number>();\r\n        for (let y = 0; y < CHUNK_SIZE; y++) {\r\n            for (let x = 0; x < CHUNK_SIZE; x++) {\r\n                const biome = tiles[y][x].biome;\r\n                biomeCounts.set(biome, (biomeCounts.get(biome) || 0) + 1);\r\n            }\r\n        }\r\n\r\n        let dominantBiome = BiomeType.PLAINS;\r\n        let maxCount = 0;\r\n        for (const [biome, count] of biomeCounts) {\r\n            if (count > maxCount && biome !== BiomeType.OCEAN && biome !== BiomeType.DEEP_OCEAN) {\r\n                maxCount = count;\r\n                dominantBiome = biome;\r\n            }\r\n        }\r\n\r\n        if (dominantBiome === BiomeType.FOREST || dominantBiome === BiomeType.MOUNTAINS ||\r\n            dominantBiome === BiomeType.DESERT || dominantBiome === BiomeType.JUNGLE ||\r\n            dominantBiome === BiomeType.TUNDRA) {\r\n\r\n            const worldX = coord.chunkX * CHUNK_SIZE + CHUNK_SIZE / 2;\r\n            const worldY = coord.chunkY * CHUNK_SIZE + CHUNK_SIZE / 2;\r\n            const regionStyle = determineRegionStyle(worldX, worldY, seed);\r\n            const name = nameGen.generateRegionName(regionStyle, dominantBiome, worldX, worldY);\r\n\r\n            labels.push({\r\n                id: `region_${coord.chunkX}_${coord.chunkY}`,\r\n                text: name,\r\n                worldX,\r\n                worldY,\r\n                type: getLabelTypeForBiome(dominantBiome),\r\n                minZoom: 0.3,\r\n                maxZoom: 5,\r\n                fontSize: 16\r\n            });\r\n        }\r\n    }\r\n\r\n    return labels;\r\n}\r\n\r\nfunction generateChunk(coord: ChunkCoordinate, seed: number, terrain: TerrainGenerator, nameGen: NameGenerator): Chunk {\r\n    const chunkSeed = hashCoordinate(coord.chunkX, coord.chunkY, seed);\r\n    const rng = createSeededRandom(chunkSeed);\r\n\r\n    const tiles: Tile[][] = [];\r\n    for (let y = 0; y < CHUNK_SIZE; y++) {\r\n        tiles[y] = [];\r\n        for (let x = 0; x < CHUNK_SIZE; x++) {\r\n            const worldX = coord.chunkX * CHUNK_SIZE + x;\r\n            const worldY = coord.chunkY * CHUNK_SIZE + y;\r\n\r\n            const elevation = terrain.getElevation(worldX, worldY);\r\n            const moisture = terrain.getMoisture(worldX, worldY);\r\n            const temperature = terrain.getTemperature(worldX, worldY);\r\n            const biome = classifyBiome(elevation, moisture, temperature);\r\n\r\n            tiles[y][x] = {\r\n                elevation,\r\n                moisture,\r\n                temperature,\r\n                biome,\r\n                riverStrength: 0,\r\n                roadType: RoadType.NONE\r\n            };\r\n        }\r\n    }\r\n\r\n    generateRivers(tiles, coord, seed, terrain);\r\n    const cities = generateCities(tiles, coord, seed, rng, terrain, nameGen);\r\n    generateRoads(tiles, cities, coord, seed, terrain);\r\n    const labels = generateLabels(tiles, cities, coord, seed, nameGen);\r\n\r\n    return {\r\n        coord,\r\n        tiles,\r\n        cities,\r\n        roadSegments: [],\r\n        labels,\r\n        generatedAt: Date.now()\r\n    };\r\n}\r\n\r\n// ============= Worker Message Handler =============\r\ninterface GenerateMessage {\r\n    type: 'generate';\r\n    chunkX: number;\r\n    chunkY: number;\r\n    seed: number;\r\n}\r\n\r\ninterface InitMessage {\r\n    type: 'init';\r\n    seed: number;\r\n}\r\n\r\ntype WorkerMessage = GenerateMessage | InitMessage;\r\n\r\nlet currentSeed: number | null = null;\r\nlet terrain: TerrainGenerator | null = null;\r\nlet nameGen: NameGenerator | null = null;\r\n\r\nfunction initGenerator(seed: number) {\r\n    if (currentSeed !== seed) {\r\n        currentSeed = seed;\r\n        terrain = createTerrainGenerator(seed);\r\n        nameGen = createNameGenerator(seed);\r\n    }\r\n}\r\n\r\n/* eslint-disable no-restricted-globals */\r\nself.onmessage = (e: MessageEvent<WorkerMessage>) => {\r\n    const message = e.data;\r\n\r\n    if (message.type === 'init') {\r\n        initGenerator(message.seed);\r\n        self.postMessage({ type: 'ready' });\r\n        return;\r\n    }\r\n\r\n    if (message.type === 'generate') {\r\n        initGenerator(message.seed);\r\n\r\n        const chunk = generateChunk(\r\n            { chunkX: message.chunkX, chunkY: message.chunkY },\r\n            message.seed,\r\n            terrain!,\r\n            nameGen!\r\n        );\r\n\r\n        self.postMessage({\r\n            type: 'chunk',\r\n            chunkX: message.chunkX,\r\n            chunkY: message.chunkY,\r\n            chunk\r\n        });\r\n    }\r\n};\r\n/* eslint-enable no-restricted-globals */\r\n\r\nexport {};\r\n"],"names":["CHUNK_SIZE","BiomeType","RoadType","LabelType","RegionStyle","createSeededRandom","seed","state","next","t","Math","imul","nextInt","max","floor","nextRange","min","nextBool","probability","arguments","length","undefined","shuffle","array","result","i","j","pick","hashCoordinate","x","y","hash","GRAD3","F2","sqrt","G2","createNoiseGenerator","rng","perm","permMod8","dot2","gx","gy","noise2D","s","x0","y0","i1","j1","x1","y1","x2","y2","ii","jj","n0","n1","n2","t0","gi0","gx0","gy0","t1","gi1","gx1","gy1","t2","gi2","gx2","gy2","octaveNoise2D","octaves","persistence","lacunarity","total","amplitude","frequency","maxValue","ridgedNoise2D","n","abs","CONTINENT_SCALE","MOUNTAIN_SCALE","DETAIL_SCALE","MOISTURE_SCALE","TEMP_SCALE","createTerrainGenerator","elevationNoise","mountainNoise","detailNoise","moistureNoise","temperatureNoise","getElevation","worldX","worldY","continent","mountains","detail","edge0","edge1","smoothstep","getMoisture","getTemperature","latitudeEffect","cos","noiseEffect","classifyBiome","elevation","moisture","temperature","DEEP_OCEAN","OCEAN","COASTAL_WATER","BEACH","SNOW_PEAKS","MOUNTAINS","HILLS","TUNDRA","DESERT","PLAINS","JUNGLE","SWAMP","FOREST","NAME_PARTS","NORDIC","prefixes","roots","suffixes","CELTIC","LATIN","EASTERN","FANTASY","BIOME_WORDS","LAKE","RIVER","determineRegionStyle","regionNoise","styles","clipLineToCircle","cx","cy","r","dx","dy","fx","fy","a","b","discriminant","sqrtD","clampedT1","clampedT2","pointToLineDistance","px","py","len2","nearX","nearY","generateCities","tiles","coord","terrain","nameGen","cities","bestScore","bestX","bestY","tile","biome","score","ny","nx","nearTile","chunkX","chunkY","regionStyle","name","generateCityName","population","radius","cityRng","streets","centerX","centerY","numRadials","angle","PI","push","type","points","sin","numRings","ringRadius","segments","gridSpacing","gridAngle","cosA","sinA","offset","generateCityStreets","buildings","buildingDensity","bx","by","tooCloseToStreet","street","p1","p2","width","height","id","toFixed","footprint","generateCityBuildings","city","ceil","ty","tx","cityId","traceHighway","position","direction","_seed","chunkWorldX","chunkWorldY","bestOffset","bestElevation","tryOffset","_tiles$y","roadType","RAIL","PAVED","pathfindRoad","startX","startY","endX","endY","openSet","closedSet","Set","startNode","g","h","f","parent","iterations","sort","current","shift","node","_tiles$node$y","NONE","add","neighbors","_tiles$ny","has","cost","existing","find","getLabelTypeForBiome","MOUNTAIN_RANGE","REGION","generateChunk","riverStrength","highestElevation","highestX","highestY","maxIterations","lowestElevation","nextX","nextY","neighborTile","generateRivers","HIGHWAY_SPACING","nearestHwyX","round","nearestHwyY","hwyOffset","hwyX","hwyY","localX","localY","nearestHwyLocalX","nearestHwyLocalY","railTarget","generateRoads","labels","text","CITY","TOWN","minZoom","maxZoom","fontSize","biomeCounts","Map","set","get","dominantBiome","maxCount","count","generateRegionName","generateLabels","roadSegments","generatedAt","Date","now","currentSeed","initGenerator","style","parts","usePrefix","useSuffix","charAt","toUpperCase","slice","biomeWords","patterns","createNameGenerator","self","onmessage","e","message","data","postMessage","chunk"],"sourceRoot":""}