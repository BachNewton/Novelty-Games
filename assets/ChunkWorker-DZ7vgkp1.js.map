{"version":3,"file":"ChunkWorker-DZ7vgkp1.js","sources":["../src/tools/world-explorer/workers/ChunkWorker.ts"],"sourcesContent":["// Web Worker for chunk generation\r\n// This file is self-contained with all dependencies inlined\r\n\r\ndeclare const self: DedicatedWorkerGlobalScope;\r\n\r\n// ============= Types (from ChunkTypes.ts) =============\r\nconst CHUNK_SIZE = 64;\r\n\r\nenum BiomeType {\r\n    DEEP_OCEAN,\r\n    OCEAN,\r\n    COASTAL_WATER,\r\n    BEACH,\r\n    PLAINS,\r\n    FOREST,\r\n    JUNGLE,\r\n    DESERT,\r\n    HILLS,\r\n    MOUNTAINS,\r\n    SNOW_PEAKS,\r\n    TUNDRA,\r\n    SWAMP,\r\n    LAKE,\r\n    RIVER\r\n}\r\n\r\nenum RoadType {\r\n    NONE,\r\n    DIRT,\r\n    PAVED,\r\n    RAIL\r\n}\r\n\r\nenum LabelType {\r\n    CITY,\r\n    TOWN,\r\n    VILLAGE,\r\n    REGION,\r\n    MOUNTAIN,\r\n    MOUNTAIN_RANGE,\r\n    LAKE,\r\n    RIVER,\r\n    SEA,\r\n    OCEAN,\r\n    FOREST,\r\n    DESERT\r\n}\r\n\r\nenum RegionStyle {\r\n    NORDIC,\r\n    CELTIC,\r\n    LATIN,\r\n    DESERT,\r\n    EASTERN,\r\n    FANTASY\r\n}\r\n\r\ninterface Tile {\r\n    elevation: number;\r\n    moisture: number;\r\n    temperature: number;\r\n    biome: BiomeType;\r\n    riverStrength: number;\r\n    roadType: RoadType;\r\n    cityId?: string;\r\n}\r\n\r\ninterface WorldCoordinate {\r\n    worldX: number;\r\n    worldY: number;\r\n}\r\n\r\ninterface ChunkCoordinate {\r\n    chunkX: number;\r\n    chunkY: number;\r\n}\r\n\r\ninterface Street {\r\n    type: 'main' | 'secondary' | 'alley';\r\n    points: WorldCoordinate[];\r\n}\r\n\r\ninterface Building {\r\n    id: string;\r\n    footprint: WorldCoordinate[];\r\n    height: number;\r\n}\r\n\r\ninterface City {\r\n    id: string;\r\n    name: string;\r\n    centerX: number;\r\n    centerY: number;\r\n    radius: number;\r\n    population: number;\r\n    regionStyle: RegionStyle;\r\n    streets: Street[];\r\n    buildings: Building[];\r\n}\r\n\r\ninterface RoadSegment {\r\n    type: RoadType;\r\n    path: WorldCoordinate[];\r\n    fromCityId: string;\r\n    toCityId: string;\r\n}\r\n\r\ninterface Label {\r\n    id: string;\r\n    text: string;\r\n    worldX: number;\r\n    worldY: number;\r\n    type: LabelType;\r\n    minZoom: number;\r\n    maxZoom: number;\r\n    fontSize: number;\r\n    rotation?: number;\r\n}\r\n\r\ninterface Chunk {\r\n    coord: ChunkCoordinate;\r\n    tiles: Tile[][];\r\n    cities: City[];\r\n    roadSegments: RoadSegment[];\r\n    labels: Label[];\r\n    generatedAt: number;\r\n}\r\n\r\n// ============= SeededRandom =============\r\ninterface SeededRandom {\r\n    next: () => number;\r\n    nextInt: (max: number) => number;\r\n    nextRange: (min: number, max: number) => number;\r\n    nextBool: (probability?: number) => boolean;\r\n    shuffle: <T>(array: T[]) => T[];\r\n    pick: <T>(array: T[]) => T;\r\n}\r\n\r\nfunction createSeededRandom(seed: number): SeededRandom {\r\n    let state = seed >>> 0;\r\n\r\n    function next(): number {\r\n        state |= 0;\r\n        state = (state + 0x6D2B79F5) | 0;\r\n        let t = Math.imul(state ^ (state >>> 15), 1 | state);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    }\r\n\r\n    return {\r\n        next,\r\n        nextInt: (max) => Math.floor(next() * max),\r\n        nextRange: (min, max) => min + next() * (max - min),\r\n        nextBool: (probability = 0.5) => next() < probability,\r\n        shuffle: <T>(array: T[]): T[] => {\r\n            const result = [...array];\r\n            for (let i = result.length - 1; i > 0; i--) {\r\n                const j = Math.floor(next() * (i + 1));\r\n                [result[i], result[j]] = [result[j], result[i]];\r\n            }\r\n            return result;\r\n        },\r\n        pick: <T>(array: T[]): T => array[Math.floor(next() * array.length)]\r\n    };\r\n}\r\n\r\nfunction hashCoordinate(x: number, y: number, seed: number): number {\r\n    let hash = seed;\r\n    hash = Math.imul(hash ^ (x | 0), 0x85ebca6b);\r\n    hash = Math.imul(hash ^ (y | 0), 0xc2b2ae35);\r\n    hash ^= hash >>> 16;\r\n    return hash >>> 0;\r\n}\r\n\r\n// ============= Noise =============\r\nconst GRAD3: [number, number][] = [\r\n    [1, 1], [-1, 1], [1, -1], [-1, -1],\r\n    [1, 0], [-1, 0], [0, 1], [0, -1]\r\n];\r\n\r\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\r\nconst G2 = (3 - Math.sqrt(3)) / 6;\r\n\r\ninterface NoiseGenerator {\r\n    noise2D: (x: number, y: number) => number;\r\n    octaveNoise2D: (x: number, y: number, octaves: number, persistence: number, lacunarity: number) => number;\r\n    ridgedNoise2D: (x: number, y: number, octaves: number, persistence: number, lacunarity: number) => number;\r\n}\r\n\r\nfunction createNoiseGenerator(seed: number): NoiseGenerator {\r\n    const rng = createSeededRandom(seed);\r\n    const perm: number[] = [];\r\n    const permMod8: number[] = [];\r\n\r\n    for (let i = 0; i < 256; i++) {\r\n        perm[i] = i;\r\n    }\r\n\r\n    for (let i = 255; i > 0; i--) {\r\n        const j = rng.nextInt(i + 1);\r\n        [perm[i], perm[j]] = [perm[j], perm[i]];\r\n    }\r\n\r\n    for (let i = 0; i < 512; i++) {\r\n        perm[i] = perm[i & 255];\r\n        permMod8[i] = perm[i] & 7;\r\n    }\r\n\r\n    function dot2(gx: number, gy: number, x: number, y: number): number {\r\n        return gx * x + gy * y;\r\n    }\r\n\r\n    function noise2D(x: number, y: number): number {\r\n        const s = (x + y) * F2;\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n\r\n        const t = (i + j) * G2;\r\n        const X0 = i - t;\r\n        const Y0 = j - t;\r\n        const x0 = x - X0;\r\n        const y0 = y - Y0;\r\n\r\n        let i1: number, j1: number;\r\n        if (x0 > y0) {\r\n            i1 = 1;\r\n            j1 = 0;\r\n        } else {\r\n            i1 = 0;\r\n            j1 = 1;\r\n        }\r\n\r\n        const x1 = x0 - i1 + G2;\r\n        const y1 = y0 - j1 + G2;\r\n        const x2 = x0 - 1 + 2 * G2;\r\n        const y2 = y0 - 1 + 2 * G2;\r\n\r\n        const ii = i & 255;\r\n        const jj = j & 255;\r\n\r\n        let n0 = 0, n1 = 0, n2 = 0;\r\n\r\n        let t0 = 0.5 - x0 * x0 - y0 * y0;\r\n        if (t0 >= 0) {\r\n            t0 *= t0;\r\n            const gi0 = permMod8[ii + perm[jj]];\r\n            const [gx0, gy0] = GRAD3[gi0];\r\n            n0 = t0 * t0 * dot2(gx0, gy0, x0, y0);\r\n        }\r\n\r\n        let t1 = 0.5 - x1 * x1 - y1 * y1;\r\n        if (t1 >= 0) {\r\n            t1 *= t1;\r\n            const gi1 = permMod8[ii + i1 + perm[jj + j1]];\r\n            const [gx1, gy1] = GRAD3[gi1];\r\n            n1 = t1 * t1 * dot2(gx1, gy1, x1, y1);\r\n        }\r\n\r\n        let t2 = 0.5 - x2 * x2 - y2 * y2;\r\n        if (t2 >= 0) {\r\n            t2 *= t2;\r\n            const gi2 = permMod8[ii + 1 + perm[jj + 1]];\r\n            const [gx2, gy2] = GRAD3[gi2];\r\n            n2 = t2 * t2 * dot2(gx2, gy2, x2, y2);\r\n        }\r\n\r\n        return 70 * (n0 + n1 + n2);\r\n    }\r\n\r\n    function octaveNoise2D(x: number, y: number, octaves: number, persistence: number, lacunarity: number): number {\r\n        let total = 0;\r\n        let amplitude = 1;\r\n        let frequency = 1;\r\n        let maxValue = 0;\r\n\r\n        for (let i = 0; i < octaves; i++) {\r\n            total += noise2D(x * frequency, y * frequency) * amplitude;\r\n            maxValue += amplitude;\r\n            amplitude *= persistence;\r\n            frequency *= lacunarity;\r\n        }\r\n\r\n        return total / maxValue;\r\n    }\r\n\r\n    function ridgedNoise2D(x: number, y: number, octaves: number, persistence: number, lacunarity: number): number {\r\n        let total = 0;\r\n        let amplitude = 1;\r\n        let frequency = 1;\r\n        let maxValue = 0;\r\n\r\n        for (let i = 0; i < octaves; i++) {\r\n            const n = 1 - Math.abs(noise2D(x * frequency, y * frequency));\r\n            total += n * n * amplitude;\r\n            maxValue += amplitude;\r\n            amplitude *= persistence;\r\n            frequency *= lacunarity;\r\n        }\r\n\r\n        return total / maxValue;\r\n    }\r\n\r\n    return { noise2D, octaveNoise2D, ridgedNoise2D };\r\n}\r\n\r\n// ============= TerrainGenerator =============\r\nconst CONTINENT_SCALE = 0.002;\r\nconst MOUNTAIN_SCALE = 0.015;\r\nconst DETAIL_SCALE = 0.08;\r\nconst MOISTURE_SCALE = 0.01;\r\nconst TEMP_SCALE = 0.005;\r\n\r\ninterface TerrainGenerator {\r\n    getElevation: (worldX: number, worldY: number) => number;\r\n    getMoisture: (worldX: number, worldY: number) => number;\r\n    getTemperature: (worldX: number, worldY: number) => number;\r\n}\r\n\r\nfunction createTerrainGenerator(seed: number): TerrainGenerator {\r\n    const elevationNoise = createNoiseGenerator(seed);\r\n    const mountainNoise = createNoiseGenerator(seed + 1000);\r\n    const detailNoise = createNoiseGenerator(seed + 2000);\r\n    const moistureNoise = createNoiseGenerator(seed + 3000);\r\n    const temperatureNoise = createNoiseGenerator(seed + 4000);\r\n\r\n    function smoothstep(edge0: number, edge1: number, x: number): number {\r\n        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));\r\n        return t * t * (3 - 2 * t);\r\n    }\r\n\r\n    return {\r\n        getElevation: (worldX, worldY) => {\r\n            const continent = elevationNoise.octaveNoise2D(\r\n                worldX * CONTINENT_SCALE, worldY * CONTINENT_SCALE, 4, 0.5, 2.0\r\n            );\r\n            const mountains = mountainNoise.ridgedNoise2D(\r\n                worldX * MOUNTAIN_SCALE, worldY * MOUNTAIN_SCALE, 4, 0.5, 2.0\r\n            );\r\n            const detail = detailNoise.octaveNoise2D(\r\n                worldX * DETAIL_SCALE, worldY * DETAIL_SCALE, 3, 0.5, 2.0\r\n            ) * 0.15;\r\n\r\n            const landMask = smoothstep(-0.1, 0.2, continent);\r\n            const baseElevation = continent * 0.4;\r\n            const mountainContribution = mountains * 0.5 * landMask;\r\n\r\n            return baseElevation + mountainContribution + detail;\r\n        },\r\n\r\n        getMoisture: (worldX, worldY) => {\r\n            const noise = moistureNoise.octaveNoise2D(\r\n                worldX * MOISTURE_SCALE, worldY * MOISTURE_SCALE, 4, 0.5, 2.0\r\n            );\r\n            return noise * 0.5 + 0.5;\r\n        },\r\n\r\n        getTemperature: (worldX, worldY) => {\r\n            const latitudeEffect = Math.cos(worldY * 0.003) * 0.4 + 0.5;\r\n            const noiseEffect = temperatureNoise.octaveNoise2D(\r\n                worldX * TEMP_SCALE, worldY * TEMP_SCALE, 3, 0.5, 2.0\r\n            ) * 0.2;\r\n            return Math.max(0, Math.min(1, latitudeEffect + noiseEffect));\r\n        }\r\n    };\r\n}\r\n\r\n// ============= BiomeClassifier =============\r\nfunction classifyBiome(elevation: number, moisture: number, temperature: number): BiomeType {\r\n    if (elevation < -0.3) return BiomeType.DEEP_OCEAN;\r\n    if (elevation < -0.15) return BiomeType.OCEAN;\r\n    if (elevation < -0.05) return BiomeType.COASTAL_WATER;\r\n    if (elevation < 0.02) return BiomeType.BEACH;\r\n\r\n    if (elevation > 0.55) return BiomeType.SNOW_PEAKS;\r\n    if (elevation > 0.4) return BiomeType.MOUNTAINS;\r\n    if (elevation > 0.25) return BiomeType.HILLS;\r\n\r\n    if (temperature < 0.25) return BiomeType.TUNDRA;\r\n\r\n    if (moisture < 0.25) return BiomeType.DESERT;\r\n\r\n    if (moisture < 0.4) {\r\n        if (temperature > 0.6) return BiomeType.DESERT;\r\n        return BiomeType.PLAINS;\r\n    }\r\n\r\n    if (moisture > 0.7) {\r\n        if (temperature > 0.65) return BiomeType.JUNGLE;\r\n        if (temperature < 0.35) return BiomeType.SWAMP;\r\n        return BiomeType.FOREST;\r\n    }\r\n\r\n    if (moisture > 0.5) {\r\n        if (temperature > 0.6) return BiomeType.JUNGLE;\r\n        return BiomeType.FOREST;\r\n    }\r\n\r\n    return BiomeType.PLAINS;\r\n}\r\n\r\nfunction isCitySuitable(biome: BiomeType): boolean {\r\n    return biome === BiomeType.PLAINS ||\r\n           biome === BiomeType.FOREST ||\r\n           biome === BiomeType.HILLS ||\r\n           biome === BiomeType.BEACH;\r\n}\r\n\r\n// ============= NameGenerator =============\r\ninterface NameParts {\r\n    prefixes: string[];\r\n    roots: string[];\r\n    suffixes: string[];\r\n}\r\n\r\nconst NAME_PARTS: Record<RegionStyle, NameParts> = {\r\n    [RegionStyle.NORDIC]: {\r\n        prefixes: ['Thor', 'Frost', 'Iron', 'Storm', 'Wolf', 'Raven', 'Snow', 'Ice', 'Stone', 'Bear'],\r\n        roots: ['heim', 'gard', 'fjord', 'vik', 'dal', 'berg', 'holm', 'vang', 'fell', 'mark'],\r\n        suffixes: ['en', '', 'stad', 'by', 'ness']\r\n    },\r\n    [RegionStyle.CELTIC]: {\r\n        prefixes: ['Dun', 'Glen', 'Bally', 'Kin', 'Strath', 'Aber', 'Kil', 'Loch', 'Ben', 'Cairn'],\r\n        roots: ['more', 'derry', 'bridge', 'ford', 'wick', 'ton', 'wood', 'field', 'vale', 'moor'],\r\n        suffixes: ['', 'ey', 'ie', 'ach', 'an']\r\n    },\r\n    [RegionStyle.LATIN]: {\r\n        prefixes: ['Port', 'Villa', 'Monte', 'Bella', 'Alta', 'Nova', 'Santa', 'San', 'Rio', 'Terra'],\r\n        roots: ['vista', 'mare', 'rosa', 'verde', 'luna', 'sol', 'oro', 'plata', 'cruz', 'piedra'],\r\n        suffixes: ['', 'ia', 'um', 'ino', 'ero']\r\n    },\r\n    [RegionStyle.DESERT]: {\r\n        prefixes: ['Al', 'El', 'Kas', 'Dar', 'Bab', 'Wadi', 'Oum', 'Ain', 'Jebel', 'Ras'],\r\n        roots: ['rashid', 'salem', 'qadir', 'malik', 'hamid', 'kareem', 'zahir', 'nadir', 'farid', 'jamil'],\r\n        suffixes: ['', 'a', 'i', 'abad', 'stan']\r\n    },\r\n    [RegionStyle.EASTERN]: {\r\n        prefixes: ['Jade', 'Golden', 'Silver', 'Dragon', 'Phoenix', 'Moon', 'Sun', 'Cloud', 'Misty', 'Crane'],\r\n        roots: ['peak', 'river', 'gate', 'bridge', 'garden', 'temple', 'spring', 'lake', 'forest', 'mountain'],\r\n        suffixes: ['', ' Valley', ' Heights', ' Crossing', '']\r\n    },\r\n    [RegionStyle.FANTASY]: {\r\n        prefixes: ['Shadow', 'Crystal', 'Silver', 'Ember', 'Thorn', 'Mist', 'Star', 'Dawn', 'Dusk', 'Rune'],\r\n        roots: ['mere', 'vale', 'spire', 'haven', 'hold', 'gate', 'wood', 'glade', 'keep', 'reach'],\r\n        suffixes: ['', 'shire', 'land', 'fell', 'dale']\r\n    }\r\n};\r\n\r\nconst BIOME_WORDS: Record<BiomeType, string[]> = {\r\n    [BiomeType.DEEP_OCEAN]: ['Abyss', 'Depths', 'Deep'],\r\n    [BiomeType.OCEAN]: ['Sea', 'Waters', 'Ocean'],\r\n    [BiomeType.COASTAL_WATER]: ['Bay', 'Gulf', 'Strait'],\r\n    [BiomeType.BEACH]: ['Shore', 'Coast', 'Strand'],\r\n    [BiomeType.PLAINS]: ['Plains', 'Grasslands', 'Steppes', 'Prairie'],\r\n    [BiomeType.FOREST]: ['Forest', 'Woods', 'Woodland', 'Grove'],\r\n    [BiomeType.JUNGLE]: ['Jungle', 'Rainforest', 'Wilds'],\r\n    [BiomeType.DESERT]: ['Desert', 'Wastes', 'Sands', 'Dunes'],\r\n    [BiomeType.HILLS]: ['Hills', 'Highlands', 'Downs'],\r\n    [BiomeType.MOUNTAINS]: ['Mountains', 'Peaks', 'Range', 'Heights'],\r\n    [BiomeType.SNOW_PEAKS]: ['Frostpeaks', 'Snowcaps', 'Icepeaks'],\r\n    [BiomeType.TUNDRA]: ['Tundra', 'Wastes', 'Barrens', 'Expanse'],\r\n    [BiomeType.SWAMP]: ['Swamp', 'Marsh', 'Bog', 'Mire'],\r\n    [BiomeType.LAKE]: ['Lake', 'Loch', 'Mere'],\r\n    [BiomeType.RIVER]: ['River', 'Stream', 'Waters']\r\n};\r\n\r\ninterface NameGenerator {\r\n    generateCityName: (style: RegionStyle, worldX: number, worldY: number) => string;\r\n    generateRegionName: (style: RegionStyle, biome: BiomeType, worldX: number, worldY: number) => string;\r\n}\r\n\r\nfunction createNameGenerator(seed: number): NameGenerator {\r\n    return {\r\n        generateCityName: (style, worldX, worldY) => {\r\n            const locationSeed = hashCoordinate(Math.floor(worldX), Math.floor(worldY), seed + 7919);\r\n            const rng = createSeededRandom(locationSeed);\r\n            const parts = NAME_PARTS[style];\r\n\r\n            const usePrefix = rng.next() < 0.7;\r\n            const useSuffix = rng.next() < 0.5;\r\n\r\n            let name = '';\r\n            if (usePrefix) name += rng.pick(parts.prefixes);\r\n            name += rng.pick(parts.roots);\r\n            if (useSuffix) name += rng.pick(parts.suffixes);\r\n\r\n            return name.charAt(0).toUpperCase() + name.slice(1);\r\n        },\r\n\r\n        generateRegionName: (style, biome, worldX, worldY) => {\r\n            const locationSeed = hashCoordinate(Math.floor(worldX), Math.floor(worldY), seed + 8923);\r\n            const rng = createSeededRandom(locationSeed);\r\n            const parts = NAME_PARTS[style];\r\n            const biomeWords = BIOME_WORDS[biome] || ['Lands'];\r\n\r\n            const patterns = [\r\n                () => `The ${rng.pick(parts.prefixes)} ${rng.pick(biomeWords)}`,\r\n                () => `${rng.pick(parts.prefixes)}${rng.pick(parts.roots)} ${rng.pick(biomeWords)}`,\r\n                () => `${rng.pick(biomeWords)} of ${rng.pick(parts.prefixes)}${rng.pick(parts.roots)}`\r\n            ];\r\n\r\n            return rng.pick(patterns)();\r\n        }\r\n    };\r\n}\r\n\r\n// ============= WorldGenerator (chunk generation) =============\r\nfunction determineRegionStyle(worldX: number, worldY: number, seed: number): RegionStyle {\r\n    const regionNoise = hashCoordinate(Math.floor(worldX / 500), Math.floor(worldY / 500), seed + 8000);\r\n    const styles = [\r\n        RegionStyle.NORDIC, RegionStyle.CELTIC, RegionStyle.LATIN,\r\n        RegionStyle.DESERT, RegionStyle.EASTERN, RegionStyle.FANTASY\r\n    ];\r\n    return styles[regionNoise % styles.length];\r\n}\r\n\r\nfunction generateRivers(tiles: Tile[][], coord: ChunkCoordinate, seed: number, terrain: TerrainGenerator): void {\r\n    const riverSeed = hashCoordinate(coord.chunkX, coord.chunkY, seed + 5000);\r\n    const rng = createSeededRandom(riverSeed);\r\n\r\n    if (rng.next() > 0.15) return;\r\n\r\n    let highestElevation = -1;\r\n    let highestX = 0;\r\n    let highestY = 0;\r\n\r\n    for (let y = 0; y < CHUNK_SIZE; y++) {\r\n        for (let x = 0; x < CHUNK_SIZE; x++) {\r\n            const tile = tiles[y][x];\r\n            if (tile.elevation > 0.3 && tile.elevation > highestElevation) {\r\n                highestElevation = tile.elevation;\r\n                highestX = x;\r\n                highestY = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (highestElevation < 0.3) return;\r\n\r\n    let x = highestX;\r\n    let y = highestY;\r\n    let iterations = 0;\r\n    const maxIterations = CHUNK_SIZE * 2;\r\n\r\n    while (iterations < maxIterations) {\r\n        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE) break;\r\n\r\n        const tile = tiles[y][x];\r\n        if (tile.biome === BiomeType.OCEAN || tile.biome === BiomeType.DEEP_OCEAN || tile.biome === BiomeType.COASTAL_WATER) {\r\n            break;\r\n        }\r\n\r\n        tile.riverStrength = Math.min(1, tile.riverStrength + 0.3 + iterations * 0.02);\r\n        if (tile.biome !== BiomeType.RIVER && tile.riverStrength > 0.5) {\r\n            tile.biome = BiomeType.RIVER;\r\n        }\r\n\r\n        let lowestElevation = tile.elevation;\r\n        let nextX = x;\r\n        let nextY = y;\r\n\r\n        const neighbors = [\r\n            [x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1],\r\n            [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1], [x + 1, y + 1]\r\n        ];\r\n\r\n        for (const [nx, ny] of neighbors) {\r\n            if (nx >= 0 && nx < CHUNK_SIZE && ny >= 0 && ny < CHUNK_SIZE) {\r\n                const neighborTile = tiles[ny][nx];\r\n                if (neighborTile.elevation < lowestElevation) {\r\n                    lowestElevation = neighborTile.elevation;\r\n                    nextX = nx;\r\n                    nextY = ny;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextX === x && nextY === y) break;\r\n\r\n        x = nextX;\r\n        y = nextY;\r\n        iterations++;\r\n    }\r\n}\r\n\r\nfunction clipLineToCircle(\r\n    x1: number, y1: number, x2: number, y2: number,\r\n    cx: number, cy: number, r: number\r\n): { worldX: number; worldY: number }[] | null {\r\n    const dx = x2 - x1;\r\n    const dy = y2 - y1;\r\n    const len = Math.sqrt(dx * dx + dy * dy);\r\n    if (len < 0.1) return null;\r\n\r\n    const fx = x1 - cx;\r\n    const fy = y1 - cy;\r\n    const a = dx * dx + dy * dy;\r\n    const b = 2 * (fx * dx + fy * dy);\r\n    const c = fx * fx + fy * fy - r * r;\r\n    const discriminant = b * b - 4 * a * c;\r\n\r\n    if (discriminant < 0) return null;\r\n\r\n    const sqrtD = Math.sqrt(discriminant);\r\n    const t1 = (-b - sqrtD) / (2 * a);\r\n    const t2 = (-b + sqrtD) / (2 * a);\r\n\r\n    if (t2 < 0 || t1 > 1) return null;\r\n\r\n    const clampedT1 = Math.max(0, t1);\r\n    const clampedT2 = Math.min(1, t2);\r\n\r\n    return [\r\n        { worldX: x1 + dx * clampedT1, worldY: y1 + dy * clampedT1 },\r\n        { worldX: x1 + dx * clampedT2, worldY: y1 + dy * clampedT2 }\r\n    ];\r\n}\r\n\r\nfunction generateCityStreets(centerX: number, centerY: number, radius: number, rng: SeededRandom): Street[] {\r\n    const streets: Street[] = [];\r\n    const isRadial = rng.next() < 0.4;\r\n\r\n    if (isRadial) {\r\n        const numRadials = 4 + Math.floor(rng.next() * 4);\r\n        for (let i = 0; i < numRadials; i++) {\r\n            const angle = (i / numRadials) * Math.PI * 2 + rng.next() * 0.2;\r\n            streets.push({\r\n                type: 'main',\r\n                points: [\r\n                    { worldX: centerX, worldY: centerY },\r\n                    { worldX: centerX + Math.cos(angle) * radius * 0.95, worldY: centerY + Math.sin(angle) * radius * 0.95 }\r\n                ]\r\n            });\r\n        }\r\n\r\n        const numRings = Math.floor(radius / 4);\r\n        for (let r = 1; r <= numRings; r++) {\r\n            const ringRadius = (r / numRings) * radius * 0.8;\r\n            const segments = 16;\r\n            const points: { worldX: number; worldY: number }[] = [];\r\n            for (let i = 0; i <= segments; i++) {\r\n                const angle = (i / segments) * Math.PI * 2;\r\n                points.push({ worldX: centerX + Math.cos(angle) * ringRadius, worldY: centerY + Math.sin(angle) * ringRadius });\r\n            }\r\n            streets.push({ type: 'secondary', points });\r\n        }\r\n    } else {\r\n        const gridSpacing = 1.5 + rng.next() * 1;\r\n        const gridAngle = rng.next() * Math.PI / 6;\r\n        const cosA = Math.cos(gridAngle);\r\n        const sinA = Math.sin(gridAngle);\r\n\r\n        for (let offset = -radius; offset <= radius; offset += gridSpacing) {\r\n            const startX = centerX + offset * cosA - radius * sinA;\r\n            const startY = centerY + offset * sinA + radius * cosA;\r\n            const endX = centerX + offset * cosA + radius * sinA;\r\n            const endY = centerY + offset * sinA - radius * cosA;\r\n\r\n            const points = clipLineToCircle(startX, startY, endX, endY, centerX, centerY, radius * 0.9);\r\n            if (points) {\r\n                streets.push({ type: Math.abs(offset) < gridSpacing ? 'main' : 'secondary', points });\r\n            }\r\n        }\r\n\r\n        for (let offset = -radius; offset <= radius; offset += gridSpacing) {\r\n            const startX = centerX + offset * sinA + radius * cosA;\r\n            const startY = centerY - offset * cosA + radius * sinA;\r\n            const endX = centerX + offset * sinA - radius * cosA;\r\n            const endY = centerY - offset * cosA - radius * sinA;\r\n\r\n            const points = clipLineToCircle(startX, startY, endX, endY, centerX, centerY, radius * 0.9);\r\n            if (points) {\r\n                streets.push({ type: Math.abs(offset) < gridSpacing ? 'main' : 'secondary', points });\r\n            }\r\n        }\r\n    }\r\n\r\n    return streets;\r\n}\r\n\r\nfunction pointToLineDistance(px: number, py: number, x1: number, y1: number, x2: number, y2: number): number {\r\n    const dx = x2 - x1;\r\n    const dy = y2 - y1;\r\n    const len2 = dx * dx + dy * dy;\r\n\r\n    if (len2 < 0.0001) {\r\n        return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);\r\n    }\r\n\r\n    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / len2));\r\n    const nearX = x1 + t * dx;\r\n    const nearY = y1 + t * dy;\r\n\r\n    return Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2);\r\n}\r\n\r\nfunction generateCityBuildings(centerX: number, centerY: number, radius: number, streets: Street[], rng: SeededRandom): Building[] {\r\n    const buildings: Building[] = [];\r\n    const buildingDensity = 0.3 + rng.next() * 0.3;\r\n    const gridStep = 0.4;\r\n\r\n    for (let dy = -radius; dy < radius; dy += gridStep) {\r\n        for (let dx = -radius; dx < radius; dx += gridStep) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist > radius * 0.85) continue;\r\n\r\n            if (rng.next() > buildingDensity) continue;\r\n\r\n            const bx = centerX + dx + (rng.next() - 0.5) * 0.2;\r\n            const by = centerY + dy + (rng.next() - 0.5) * 0.2;\r\n\r\n            let tooCloseToStreet = false;\r\n            for (const street of streets) {\r\n                for (let i = 0; i < street.points.length - 1; i++) {\r\n                    const p1 = street.points[i];\r\n                    const p2 = street.points[i + 1];\r\n                    const distToStreet = pointToLineDistance(bx, by, p1.worldX, p1.worldY, p2.worldX, p2.worldY);\r\n                    if (distToStreet < 0.3) {\r\n                        tooCloseToStreet = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (tooCloseToStreet) break;\r\n            }\r\n\r\n            if (tooCloseToStreet) continue;\r\n\r\n            const width = 0.15 + rng.next() * 0.2;\r\n            const height = 0.15 + rng.next() * 0.2;\r\n\r\n            buildings.push({\r\n                id: `building_${bx.toFixed(2)}_${by.toFixed(2)}`,\r\n                footprint: [\r\n                    { worldX: bx - width / 2, worldY: by - height / 2 },\r\n                    { worldX: bx + width / 2, worldY: by - height / 2 },\r\n                    { worldX: bx + width / 2, worldY: by + height / 2 },\r\n                    { worldX: bx - width / 2, worldY: by + height / 2 }\r\n                ],\r\n                height: 1 + rng.next() * 3\r\n            });\r\n        }\r\n    }\r\n\r\n    return buildings;\r\n}\r\n\r\nfunction generateCities(\r\n    tiles: Tile[][], coord: ChunkCoordinate, seed: number,\r\n    rng: SeededRandom, terrain: TerrainGenerator, nameGen: NameGenerator\r\n): City[] {\r\n    const cities: City[] = [];\r\n\r\n    if (rng.next() > 0.08) return cities;\r\n\r\n    let bestScore = 0;\r\n    let bestX = CHUNK_SIZE / 2;\r\n    let bestY = CHUNK_SIZE / 2;\r\n\r\n    for (let y = 8; y < CHUNK_SIZE - 8; y += 8) {\r\n        for (let x = 8; x < CHUNK_SIZE - 8; x += 8) {\r\n            const tile = tiles[y][x];\r\n            if (!isCitySuitable(tile.biome)) continue;\r\n\r\n            let score = 1;\r\n            score += (1 - Math.abs(tile.elevation - 0.1)) * 2;\r\n            score += (1 - Math.abs(tile.moisture - 0.5)) * 1.5;\r\n\r\n            for (let dy = -5; dy <= 5; dy++) {\r\n                for (let dx = -5; dx <= 5; dx++) {\r\n                    const ny = y + dy;\r\n                    const nx = x + dx;\r\n                    if (ny >= 0 && ny < CHUNK_SIZE && nx >= 0 && nx < CHUNK_SIZE) {\r\n                        const nearTile = tiles[ny][nx];\r\n                        if (nearTile.biome === BiomeType.RIVER || nearTile.biome === BiomeType.COASTAL_WATER) {\r\n                            score += 0.5;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (score > bestScore) {\r\n                bestScore = score;\r\n                bestX = x;\r\n                bestY = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (bestScore < 2) return cities;\r\n\r\n    const worldX = coord.chunkX * CHUNK_SIZE + bestX;\r\n    const worldY = coord.chunkY * CHUNK_SIZE + bestY;\r\n    const regionStyle = determineRegionStyle(worldX, worldY, seed);\r\n    const name = nameGen.generateCityName(regionStyle, worldX, worldY);\r\n    const population = Math.floor(500 + rng.next() * 50000);\r\n    const radius = 3 + Math.sqrt(population / 1000);\r\n\r\n    const cityRng = createSeededRandom(hashCoordinate(worldX, worldY, seed + 6000));\r\n    const streets = generateCityStreets(worldX, worldY, radius, cityRng);\r\n    const buildings = generateCityBuildings(worldX, worldY, radius, streets, cityRng);\r\n\r\n    const city: City = {\r\n        id: `city_${worldX}_${worldY}`,\r\n        name,\r\n        centerX: worldX,\r\n        centerY: worldY,\r\n        radius,\r\n        population,\r\n        regionStyle,\r\n        streets,\r\n        buildings\r\n    };\r\n\r\n    cities.push(city);\r\n\r\n    for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {\r\n        for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            if (dist <= radius) {\r\n                const ty = bestY + dy;\r\n                const tx = bestX + dx;\r\n                if (ty >= 0 && ty < CHUNK_SIZE && tx >= 0 && tx < CHUNK_SIZE) {\r\n                    tiles[ty][tx].cityId = city.id;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return cities;\r\n}\r\n\r\nfunction traceHighway(\r\n    tiles: Tile[][], position: number, direction: 'horizontal' | 'vertical',\r\n    coord: ChunkCoordinate, _seed: number, terrain: TerrainGenerator\r\n): void {\r\n    const chunkWorldX = coord.chunkX * CHUNK_SIZE;\r\n    const chunkWorldY = coord.chunkY * CHUNK_SIZE;\r\n\r\n    let offset = 0;\r\n    const maxOffset = 15;\r\n\r\n    for (let i = 0; i < CHUNK_SIZE; i++) {\r\n        let bestOffset = offset;\r\n        let bestElevation = -999;\r\n\r\n        for (let tryOffset = -maxOffset; tryOffset <= maxOffset; tryOffset++) {\r\n            let x: number, y: number;\r\n            let worldX: number, worldY: number;\r\n\r\n            if (direction === 'vertical') {\r\n                x = position + tryOffset;\r\n                y = i;\r\n            } else {\r\n                x = i;\r\n                y = position + tryOffset;\r\n            }\r\n\r\n            if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE) continue;\r\n\r\n            worldX = chunkWorldX + x;\r\n            worldY = chunkWorldY + y;\r\n\r\n            const elevation = terrain.getElevation(worldX, worldY);\r\n            if (elevation < -0.05 || elevation > 0.45) continue;\r\n\r\n            const score = -Math.abs(tryOffset) * 0.1 - Math.abs(elevation - 0.1);\r\n            if (score > bestElevation) {\r\n                bestElevation = score;\r\n                bestOffset = tryOffset;\r\n            }\r\n        }\r\n\r\n        if (bestElevation > -999) {\r\n            offset = bestOffset;\r\n\r\n            let x: number, y: number;\r\n            if (direction === 'vertical') {\r\n                x = Math.max(0, Math.min(CHUNK_SIZE - 1, position + offset));\r\n                y = i;\r\n            } else {\r\n                x = i;\r\n                y = Math.max(0, Math.min(CHUNK_SIZE - 1, position + offset));\r\n            }\r\n\r\n            const tile = tiles[y]?.[x];\r\n            if (tile && tile.roadType !== RoadType.RAIL) {\r\n                tile.roadType = RoadType.PAVED;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction pathfindRoad(\r\n    tiles: Tile[][], startX: number, startY: number, endX: number, endY: number,\r\n    terrain: TerrainGenerator, coord: ChunkCoordinate, roadType: RoadType\r\n): void {\r\n    const chunkWorldX = coord.chunkX * CHUNK_SIZE;\r\n    const chunkWorldY = coord.chunkY * CHUNK_SIZE;\r\n\r\n    interface Node {\r\n        x: number; y: number; g: number; h: number; f: number; parent: Node | null;\r\n    }\r\n\r\n    const openSet: Node[] = [];\r\n    const closedSet = new Set<string>();\r\n\r\n    const startNode: Node = {\r\n        x: startX, y: startY, g: 0,\r\n        h: Math.abs(endX - startX) + Math.abs(endY - startY),\r\n        f: Math.abs(endX - startX) + Math.abs(endY - startY),\r\n        parent: null\r\n    };\r\n    openSet.push(startNode);\r\n\r\n    const maxIterations = 500;\r\n    let iterations = 0;\r\n\r\n    while (openSet.length > 0 && iterations < maxIterations) {\r\n        iterations++;\r\n\r\n        openSet.sort((a, b) => a.f - b.f);\r\n        const current = openSet.shift()!;\r\n\r\n        if (current.x === endX && current.y === endY) {\r\n            let node: Node | null = current;\r\n            while (node) {\r\n                const tile = tiles[node.y]?.[node.x];\r\n                if (tile && (tile.roadType === RoadType.NONE ||\r\n                    (roadType === RoadType.RAIL && tile.roadType !== RoadType.RAIL))) {\r\n                    tile.roadType = roadType;\r\n                }\r\n                node = node.parent;\r\n            }\r\n            return;\r\n        }\r\n\r\n        closedSet.add(`${current.x},${current.y}`);\r\n\r\n        const neighbors = [\r\n            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },\r\n            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }\r\n        ];\r\n\r\n        for (const { dx, dy } of neighbors) {\r\n            const nx = current.x + dx;\r\n            const ny = current.y + dy;\r\n\r\n            if (nx < 0 || nx >= CHUNK_SIZE || ny < 0 || ny >= CHUNK_SIZE) continue;\r\n            if (closedSet.has(`${nx},${ny}`)) continue;\r\n\r\n            const tile = tiles[ny]?.[nx];\r\n            if (!tile) continue;\r\n\r\n            const worldX = chunkWorldX + nx;\r\n            const worldY = chunkWorldY + ny;\r\n            const elevation = terrain.getElevation(worldX, worldY);\r\n\r\n            if (tile.biome === BiomeType.OCEAN || tile.biome === BiomeType.DEEP_OCEAN ||\r\n                tile.biome === BiomeType.COASTAL_WATER || tile.biome === BiomeType.LAKE ||\r\n                elevation < -0.05 || elevation > 0.45) {\r\n                continue;\r\n            }\r\n\r\n            let cost = 1;\r\n            if (elevation > 0.35) cost = 8;\r\n            else if (elevation > 0.25) cost = 3;\r\n            else if (tile.biome === BiomeType.RIVER) cost = 4;\r\n\r\n            const g = current.g + cost;\r\n            const h = Math.abs(endX - nx) + Math.abs(endY - ny);\r\n            const f = g + h;\r\n\r\n            const existing = openSet.find(n => n.x === nx && n.y === ny);\r\n            if (existing && existing.f <= f) continue;\r\n\r\n            if (existing) {\r\n                existing.g = g;\r\n                existing.h = h;\r\n                existing.f = f;\r\n                existing.parent = current;\r\n            } else {\r\n                openSet.push({ x: nx, y: ny, g, h, f, parent: current });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction generateRoads(tiles: Tile[][], cities: City[], coord: ChunkCoordinate, seed: number, terrain: TerrainGenerator): void {\r\n    const chunkWorldX = coord.chunkX * CHUNK_SIZE;\r\n    const chunkWorldY = coord.chunkY * CHUNK_SIZE;\r\n    const HIGHWAY_SPACING = 80;\r\n\r\n    const nearestHwyX = Math.round(chunkWorldX / HIGHWAY_SPACING) * HIGHWAY_SPACING;\r\n    const nearestHwyY = Math.round(chunkWorldY / HIGHWAY_SPACING) * HIGHWAY_SPACING;\r\n\r\n    for (let hwyOffset = -HIGHWAY_SPACING; hwyOffset <= HIGHWAY_SPACING + CHUNK_SIZE; hwyOffset += HIGHWAY_SPACING) {\r\n        const hwyX = nearestHwyX + hwyOffset - chunkWorldX;\r\n        if (hwyX >= -5 && hwyX < CHUNK_SIZE + 5) {\r\n            traceHighway(tiles, Math.floor(hwyX), 'vertical', coord, seed, terrain);\r\n        }\r\n\r\n        const hwyY = nearestHwyY + hwyOffset - chunkWorldY;\r\n        if (hwyY >= -5 && hwyY < CHUNK_SIZE + 5) {\r\n            traceHighway(tiles, Math.floor(hwyY), 'horizontal', coord, seed, terrain);\r\n        }\r\n    }\r\n\r\n    for (const city of cities) {\r\n        const localX = Math.floor(city.centerX - chunkWorldX);\r\n        const localY = Math.floor(city.centerY - chunkWorldY);\r\n\r\n        const nearestHwyLocalX = Math.round((city.centerX) / HIGHWAY_SPACING) * HIGHWAY_SPACING - chunkWorldX;\r\n        const nearestHwyLocalY = Math.round((city.centerY) / HIGHWAY_SPACING) * HIGHWAY_SPACING - chunkWorldY;\r\n\r\n        if (nearestHwyLocalX >= 0 && nearestHwyLocalX < CHUNK_SIZE) {\r\n            pathfindRoad(tiles, localX, localY, Math.floor(nearestHwyLocalX), localY, terrain, coord, RoadType.PAVED);\r\n        }\r\n\r\n        if (nearestHwyLocalY >= 0 && nearestHwyLocalY < CHUNK_SIZE) {\r\n            pathfindRoad(tiles, localX, localY, localX, Math.floor(nearestHwyLocalY), terrain, coord, RoadType.PAVED);\r\n        }\r\n\r\n        if (city.population > 15000) {\r\n            const railTarget = Math.abs(nearestHwyLocalX - localX) < Math.abs(nearestHwyLocalY - localY)\r\n                ? { x: Math.floor(nearestHwyLocalX), y: localY }\r\n                : { x: localX, y: Math.floor(nearestHwyLocalY) };\r\n\r\n            if (railTarget.x >= 0 && railTarget.x < CHUNK_SIZE && railTarget.y >= 0 && railTarget.y < CHUNK_SIZE) {\r\n                pathfindRoad(tiles, localX, localY, railTarget.x, railTarget.y, terrain, coord, RoadType.RAIL);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getLabelTypeForBiome(biome: BiomeType): LabelType {\r\n    switch (biome) {\r\n        case BiomeType.FOREST:\r\n        case BiomeType.JUNGLE:\r\n            return LabelType.FOREST;\r\n        case BiomeType.MOUNTAINS:\r\n        case BiomeType.SNOW_PEAKS:\r\n            return LabelType.MOUNTAIN_RANGE;\r\n        case BiomeType.DESERT:\r\n            return LabelType.DESERT;\r\n        default:\r\n            return LabelType.REGION;\r\n    }\r\n}\r\n\r\nfunction generateLabels(tiles: Tile[][], cities: City[], coord: ChunkCoordinate, seed: number, nameGen: NameGenerator): Label[] {\r\n    const labels: Label[] = [];\r\n\r\n    for (const city of cities) {\r\n        labels.push({\r\n            id: `label_${city.id}`,\r\n            text: city.name,\r\n            worldX: city.centerX,\r\n            worldY: city.centerY + city.radius + 2,\r\n            type: city.population > 10000 ? LabelType.CITY : LabelType.TOWN,\r\n            minZoom: city.population > 10000 ? 0.5 : 2,\r\n            maxZoom: 100,\r\n            fontSize: city.population > 10000 ? 14 : 11\r\n        });\r\n    }\r\n\r\n    const labelRng = createSeededRandom(hashCoordinate(coord.chunkX, coord.chunkY, seed + 9000));\r\n\r\n    if (labelRng.next() < 0.1) {\r\n        const biomeCounts = new Map<BiomeType, number>();\r\n        for (let y = 0; y < CHUNK_SIZE; y++) {\r\n            for (let x = 0; x < CHUNK_SIZE; x++) {\r\n                const biome = tiles[y][x].biome;\r\n                biomeCounts.set(biome, (biomeCounts.get(biome) || 0) + 1);\r\n            }\r\n        }\r\n\r\n        let dominantBiome = BiomeType.PLAINS;\r\n        let maxCount = 0;\r\n        for (const [biome, count] of biomeCounts) {\r\n            if (count > maxCount && biome !== BiomeType.OCEAN && biome !== BiomeType.DEEP_OCEAN) {\r\n                maxCount = count;\r\n                dominantBiome = biome;\r\n            }\r\n        }\r\n\r\n        if (dominantBiome === BiomeType.FOREST || dominantBiome === BiomeType.MOUNTAINS ||\r\n            dominantBiome === BiomeType.DESERT || dominantBiome === BiomeType.JUNGLE ||\r\n            dominantBiome === BiomeType.TUNDRA) {\r\n\r\n            const worldX = coord.chunkX * CHUNK_SIZE + CHUNK_SIZE / 2;\r\n            const worldY = coord.chunkY * CHUNK_SIZE + CHUNK_SIZE / 2;\r\n            const regionStyle = determineRegionStyle(worldX, worldY, seed);\r\n            const name = nameGen.generateRegionName(regionStyle, dominantBiome, worldX, worldY);\r\n\r\n            labels.push({\r\n                id: `region_${coord.chunkX}_${coord.chunkY}`,\r\n                text: name,\r\n                worldX,\r\n                worldY,\r\n                type: getLabelTypeForBiome(dominantBiome),\r\n                minZoom: 0.3,\r\n                maxZoom: 5,\r\n                fontSize: 16\r\n            });\r\n        }\r\n    }\r\n\r\n    return labels;\r\n}\r\n\r\nfunction generateChunk(coord: ChunkCoordinate, seed: number, terrain: TerrainGenerator, nameGen: NameGenerator): Chunk {\r\n    const chunkSeed = hashCoordinate(coord.chunkX, coord.chunkY, seed);\r\n    const rng = createSeededRandom(chunkSeed);\r\n\r\n    const tiles: Tile[][] = [];\r\n    for (let y = 0; y < CHUNK_SIZE; y++) {\r\n        tiles[y] = [];\r\n        for (let x = 0; x < CHUNK_SIZE; x++) {\r\n            const worldX = coord.chunkX * CHUNK_SIZE + x;\r\n            const worldY = coord.chunkY * CHUNK_SIZE + y;\r\n\r\n            const elevation = terrain.getElevation(worldX, worldY);\r\n            const moisture = terrain.getMoisture(worldX, worldY);\r\n            const temperature = terrain.getTemperature(worldX, worldY);\r\n            const biome = classifyBiome(elevation, moisture, temperature);\r\n\r\n            tiles[y][x] = {\r\n                elevation,\r\n                moisture,\r\n                temperature,\r\n                biome,\r\n                riverStrength: 0,\r\n                roadType: RoadType.NONE\r\n            };\r\n        }\r\n    }\r\n\r\n    generateRivers(tiles, coord, seed, terrain);\r\n    const cities = generateCities(tiles, coord, seed, rng, terrain, nameGen);\r\n    generateRoads(tiles, cities, coord, seed, terrain);\r\n    const labels = generateLabels(tiles, cities, coord, seed, nameGen);\r\n\r\n    return {\r\n        coord,\r\n        tiles,\r\n        cities,\r\n        roadSegments: [],\r\n        labels,\r\n        generatedAt: Date.now()\r\n    };\r\n}\r\n\r\n// ============= Worker Message Handler =============\r\ninterface GenerateMessage {\r\n    type: 'generate';\r\n    chunkX: number;\r\n    chunkY: number;\r\n    seed: number;\r\n}\r\n\r\ninterface InitMessage {\r\n    type: 'init';\r\n    seed: number;\r\n}\r\n\r\ntype WorkerMessage = GenerateMessage | InitMessage;\r\n\r\nlet currentSeed: number | null = null;\r\nlet terrain: TerrainGenerator | null = null;\r\nlet nameGen: NameGenerator | null = null;\r\n\r\nfunction initGenerator(seed: number) {\r\n    if (currentSeed !== seed) {\r\n        currentSeed = seed;\r\n        terrain = createTerrainGenerator(seed);\r\n        nameGen = createNameGenerator(seed);\r\n    }\r\n}\r\n\r\n/* eslint-disable no-restricted-globals */\r\nself.onmessage = (e: MessageEvent<WorkerMessage>) => {\r\n    const message = e.data;\r\n\r\n    if (message.type === 'init') {\r\n        initGenerator(message.seed);\r\n        self.postMessage({ type: 'ready' });\r\n        return;\r\n    }\r\n\r\n    if (message.type === 'generate') {\r\n        initGenerator(message.seed);\r\n\r\n        const chunk = generateChunk(\r\n            { chunkX: message.chunkX, chunkY: message.chunkY },\r\n            message.seed,\r\n            terrain!,\r\n            nameGen!\r\n        );\r\n\r\n        self.postMessage({\r\n            type: 'chunk',\r\n            chunkX: message.chunkX,\r\n            chunkY: message.chunkY,\r\n            chunk\r\n        });\r\n    }\r\n};\r\n/* eslint-enable no-restricted-globals */\r\n\r\nexport {};\r\n"],"names":["createSeededRandom","seed","state","next","t","max","min","probability","array","result","i","j","hashCoordinate","x","y","hash","GRAD3","F2","G2","createNoiseGenerator","rng","perm","permMod8","dot2","gx","gy","noise2D","s","X0","Y0","x0","y0","i1","j1","x1","y1","x2","y2","ii","jj","n0","n1","n2","t0","gi0","gx0","gy0","t1","gi1","gx1","gy1","t2","gi2","gx2","gy2","octaveNoise2D","octaves","persistence","lacunarity","total","amplitude","frequency","maxValue","ridgedNoise2D","n","CONTINENT_SCALE","MOUNTAIN_SCALE","DETAIL_SCALE","MOISTURE_SCALE","TEMP_SCALE","createTerrainGenerator","elevationNoise","mountainNoise","detailNoise","moistureNoise","temperatureNoise","smoothstep","edge0","edge1","worldX","worldY","continent","mountains","detail","landMask","baseElevation","mountainContribution","latitudeEffect","noiseEffect","classifyBiome","elevation","moisture","temperature","isCitySuitable","biome","NAME_PARTS","BIOME_WORDS","createNameGenerator","style","locationSeed","parts","usePrefix","useSuffix","name","biomeWords","patterns","determineRegionStyle","regionNoise","styles","generateRivers","tiles","coord","terrain","riverSeed","highestElevation","highestX","highestY","tile","iterations","maxIterations","lowestElevation","nextX","nextY","neighbors","nx","ny","neighborTile","clipLineToCircle","cx","cy","r","dx","dy","fx","fy","a","b","c","discriminant","sqrtD","clampedT1","clampedT2","generateCityStreets","centerX","centerY","radius","streets","numRadials","angle","numRings","ringRadius","segments","points","gridSpacing","gridAngle","cosA","sinA","offset","startX","startY","endX","endY","pointToLineDistance","px","py","len2","nearX","nearY","generateCityBuildings","buildings","buildingDensity","gridStep","bx","by","tooCloseToStreet","street","p1","p2","width","height","generateCities","nameGen","cities","bestScore","bestX","bestY","score","nearTile","regionStyle","population","cityRng","city","ty","tx","traceHighway","position","direction","_seed","chunkWorldX","chunkWorldY","maxOffset","bestOffset","bestElevation","tryOffset","_a","pathfindRoad","roadType","openSet","closedSet","startNode","current","node","_b","cost","g","h","f","existing","generateRoads","HIGHWAY_SPACING","nearestHwyX","nearestHwyY","hwyOffset","hwyX","hwyY","localX","localY","nearestHwyLocalX","nearestHwyLocalY","railTarget","getLabelTypeForBiome","generateLabels","labels","biomeCounts","dominantBiome","maxCount","count","generateChunk","chunkSeed","currentSeed","initGenerator","e","message","chunk"],"mappings":"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"}